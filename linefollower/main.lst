   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 108               	.global	clock_init
 110               	clock_init:
 111               		.stabd	46,0,0
   1:main.c        **** /*
   2:main.c        **** //Follow the damn line
   3:main.c        **** char Author [] ="Cody Schafer";
   4:main.c        **** */
   5:main.c        **** 
   6:main.c        **** #include <stdbool.h>
   7:main.c        **** #include "defines.h"
   8:main.c        **** #include "usart.h"
   9:main.c        **** #include "adc.h"
  10:main.c        **** #include "motor.h"
  11:main.c        **** #include "timers.h"
  12:main.c        **** #include "joystick.h"
  13:main.c        **** #include <avr/power.h>
  14:main.c        **** #include <stdio.h>
  15:main.c        **** #include <avr/io.h>
  16:main.c        **** #include <avr/interrupt.h>
  17:main.c        **** #include <util/delay.h>
  18:main.c        **** #include <avr/pgmspace.h>
  19:main.c        **** 
  20:main.c        **** 
  21:main.c        **** void clock_init(void) {
 113               	.LM0:
 114               	.LFBB1:
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	.LBB27:
  22:main.c        **** 	
  23:main.c        **** 	#if   F_CPU == 1000000
  24:main.c        **** 		clock_prescale_set(clock_div_8);	
  25:main.c        **** 	#elif F_CPU == 2000000
  26:main.c        **** 		clock_prescale_set(clock_div_4);	
  27:main.c        **** 	#elif F_CPU == 4000000
  28:main.c        **** 		clock_prescale_set(clock_div_2);	
  29:main.c        **** 	#elif F_CPU == 8000000
  30:main.c        **** 		clock_prescale_set(clock_div_1);	
 119               	.LM1:
 120 0000 80E0      		ldi r24,lo8(0)
 121 0002 90E0      		ldi r25,hi8(0)
 122 0004 20E8      		ldi r18,lo8(-128)
 123               	/* #APP */
 124               	 ;  30 "main.c" 1
 125 0006 0FB6      		in __tmp_reg__,__SREG__
 126 0008 F894      		cli
 127 000a 2093 6100 		sts 97, r18
 128 000e 8093 6100 		sts 97, r24
 129 0012 0FBE      		out __SREG__, __tmp_reg__
 130               	 ;  0 "" 2
 131               	/* epilogue start */
 132               	/* #NOAPP */
 133               	.LBE27:
  31:main.c        **** 	#else
  32:main.c        **** 		#error "F_CPU Unrecognized"
  33:main.c        **** 	#endif
  34:main.c        **** 	
  35:main.c        **** 	//OSCAL set by the bootloader.
  36:main.c        **** }
 135               	.LM2:
 136 0014 0895      		ret
 138               	.Lscope1:
 140               		.stabd	78,0,0
 142               	.global	__vector_default
 144               	__vector_default:
 145               		.stabd	46,0,0
  37:main.c        **** 
  38:main.c        **** void  print_bin(uint8_t inp) {
  39:main.c        **** 	for(int8_t j=7; j>=0; --j) {
  40:main.c        **** 	   	printf("%c",((inp&(1<<j))>>j)+'0');
  41:main.c        **** 	}
  42:main.c        **** }
  43:main.c        **** 
  44:main.c        **** void init(void) {
  45:main.c        **** 	cli();
  46:main.c        **** 	power_lcd_disable();
  47:main.c        **** 	power_spi_disable();
  48:main.c        **** 	clock_init();
  49:main.c        **** 	joy_init();
  50:main.c        **** 	usart_init();
  51:main.c        **** 	adc_init();
  52:main.c        **** 	timers_init();
  53:main.c        **** 	motors_init();
  54:main.c        **** 	sei();
  55:main.c        **** 	#ifdef debug
  56:main.c        **** 	printf_P(PSTR("\nInit: Done\n\n"));
  57:main.c        **** 	#endif
  58:main.c        **** }
  59:main.c        **** 
  60:main.c        **** 
  61:main.c        **** 
  62:main.c        **** int main(void) {
  63:main.c        **** 	init();
  64:main.c        **** 	c_mode=WAIT;
  65:main.c        **** 	initial=true;
  66:main.c        **** 	
  67:main.c        **** 		
  68:main.c        **** 	for(;;) {
  69:main.c        **** 		if	(c_mode==FOLLOW) {	
  70:main.c        **** 			if (initial) {
  71:main.c        **** 				lf_full_speed();
  72:main.c        **** 				initial=false;
  73:main.c        **** 			}
  74:main.c        **** //			uint16_t c_speed [2] = {motor_get_speed(LEFT),motor_get_speed(RIGHT)};
  75:main.c        **** 
  76:main.c        **** 			uint16_t adc_vc[channel_amt];
  77:main.c        **** 			for (uint8_t i=0;i<channel_amt;++i) {
  78:main.c        **** 				adc_vc[i]=adc_get_val(i);
  79:main.c        **** 			}
  80:main.c        **** 			
  81:main.c        **** 			uint8_t  maxi=channel_amt;
  82:main.c        **** 			uint16_t maxv=0;
  83:main.c        **** 			for (uint8_t i=0;i<channel_amt;++i) {
  84:main.c        **** 				if (adc_vc[i]>maxv) {
  85:main.c        **** 					maxi=i;
  86:main.c        **** 					maxv=adc_vc[i];
  87:main.c        **** 				}
  88:main.c        **** 			}
  89:main.c        **** 			
  90:main.c        **** 			#ifdef debug
  91:main.c        **** 			print_adc_values();
  92:main.c        **** 			printf_P(PSTR("\nMax Channel [L 0 1 2 3 R]: %d;v=%d"),maxi,maxv);
  93:main.c        **** 			#endif
  94:main.c        **** 
  95:main.c        **** 			int8_t turn_i;			
  96:main.c        **** 			turn_i = maxi-channel_amt/2; // Needs to work for even numbers....
  97:main.c        **** 			
  98:main.c        **** 			// Correction needed for even numbers of sensors.
  99:main.c        **** 			#if (!(channel_amt%2))
 100:main.c        **** 			if (turn_i>0)
 101:main.c        **** 				++turn_i;	
 102:main.c        **** 			#endif
 103:main.c        **** 
 104:main.c        **** 			lf_turn_inc(abs(LF_INC_SMALL*turn_i),turn_i>=0);
 105:main.c        **** 			
 106:main.c        **** 			
 107:main.c        **** 			//0=LEFT, 3=RIGHT
 108:main.c        **** 			/*
 109:main.c        **** 			if		((adc_vc[0]>adc_vc[1])&&(adc_vc[0]>adc_vc[2])&&(adc_vc[0]>adc_vc[3])) {
 110:main.c        **** 				lf_turn_inc(LF_INC_LARGE,NEG);
 111:main.c        **** 				dir=LEFT;
 112:main.c        **** 			}
 113:main.c        **** 			else if ((adc_vc[3]>adc_vc[0])&&(adc_vc[3]>adc_vc[1])&&(adc_vc[3]>adc_vc[2])) {
 114:main.c        **** 				lf_turn_inc(LF_INC_LARGE,POS);
 115:main.c        **** 				dir=RIGHT;
 116:main.c        **** 			}
 117:main.c        **** 			else if	((adc_vc[2]>adc_vc[0])&&(adc_vc[2]>adc_vc[1])&&(adc_vc[2]>adc_vc[3])) {
 118:main.c        **** 				lf_turn_inc(LF_INC_SMALL,NEG);
 119:main.c        **** 				dir=LEFT;
 120:main.c        **** 			}
 121:main.c        **** 			else if ((adc_vc[1]>adc_vc[0])&&(adc_vc[1]>adc_vc[2])&&(adc_vc[1]>adc_vc[3])) {
 122:main.c        **** 				lf_turn_inc(LF_INC_LARGE,POS);
 123:main.c        **** 				dir=RIGHT;
 124:main.c        **** 			}
 125:main.c        **** 			else if ((adc_vc[0]<adc_vc[1])&&(adc_vc[2]>adc_vc[3])) {
 126:main.c        **** 				//lf_full_speed();
 127:main.c        **** 				dir=FWD;
 128:main.c        **** 			}
 129:main.c        **** 			else if ((adc_vc[0]==adc_vc[1])&&(adc_vc[1]==adc_vc[2])&&(adc_vc[2]==adc_vc[3])){
 130:main.c        **** 				//lf_full_speed();
 131:main.c        **** 				dir=FWD;
 132:main.c        **** 			}
 133:main.c        **** 			*/
 134:main.c        **** 
 135:main.c        **** 			_delay_ms(200);
 136:main.c        **** 			// do at every adc calc or pwm vector.
 137:main.c        **** 		}
 138:main.c        **** 		else if	(c_mode==TEST) {
 139:main.c        **** 			if (initial) {
 140:main.c        **** 				motor_mode(MOTOR_L_FWD,LEFT);
 141:main.c        **** 				motor_mode(MOTOR_R_FWD,RIGHT);
 142:main.c        **** 				initial=false;
 143:main.c        **** 			}
 144:main.c        **** 			static uint16_t sp;
 145:main.c        **** 			
 146:main.c        **** 			motor_set_speed(sp,LEFT);
 147:main.c        **** 			motor_set_speed(sp,RIGHT);
 148:main.c        **** 			_delay_ms(2);
 149:main.c        **** 			//if (!(sp%0x100))
 150:main.c        **** 			//	printf("\nsp=%x",sp);
 151:main.c        **** 			++sp;
 152:main.c        **** 		}
 153:main.c        **** 	}	
 154:main.c        **** } 
 155:main.c        **** 		
 156:main.c        **** ISR(BADISR_vect) {
 147               	.LM3:
 148               	.LFBB2:
 149 0016 1F92      		push __zero_reg__
 150 0018 0F92      		push r0
 151 001a 0FB6      		in r0,__SREG__
 152 001c 0F92      		push r0
 153 001e 1124      		clr __zero_reg__
 154 0020 8F93      		push r24
 155 0022 9F93      		push r25
 156               	/* prologue: Signal */
 157               	/* frame size = 0 */
 157:main.c        **** 	printf_P(PSTR("\n\nInvalid Interupt Enabled\n"));
 159               	.LM4:
 160 0024 80E0      		ldi r24,lo8(__c.1640)
 161 0026 90E0      		ldi r25,hi8(__c.1640)
 162 0028 9F93      		push r25
 163 002a 8F93      		push r24
 164 002c 0E94 0000 		call printf_P
 165 0030 0F90      		pop __tmp_reg__
 166 0032 0F90      		pop __tmp_reg__
 167               	/* epilogue start */
 158:main.c        **** }
 169               	.LM5:
 170 0034 9F91      		pop r25
 171 0036 8F91      		pop r24
 172 0038 0F90      		pop r0
 173 003a 0FBE      		out __SREG__,r0
 174 003c 0F90      		pop r0
 175 003e 1F90      		pop __zero_reg__
 176 0040 1895      		reti
 178               	.Lscope2:
 180               		.stabd	78,0,0
 182               	.global	init
 184               	init:
 185               		.stabd	46,0,0
 187               	.LM6:
 188               	.LFBB3:
 189               	/* prologue: function */
 190               	/* frame size = 0 */
 192               	.LM7:
 193               	/* #APP */
 194               	 ;  45 "main.c" 1
 195 0042 F894      		cli
 196               	 ;  0 "" 2
 198               	.LM8:
 199               	/* #NOAPP */
 200 0044 E4E6      		ldi r30,lo8(100)
 201 0046 F0E0      		ldi r31,hi8(100)
 202 0048 8081      		ld r24,Z
 203 004a 8061      		ori r24,lo8(16)
 204 004c 8083      		st Z,r24
 206               	.LM9:
 207 004e 8081      		ld r24,Z
 208 0050 8460      		ori r24,lo8(4)
 209 0052 8083      		st Z,r24
 210               	.LBB28:
 211               	.LBB29:
 212               	.LBB30:
 214               	.LM10:
 215 0054 80E0      		ldi r24,lo8(0)
 216 0056 90E0      		ldi r25,hi8(0)
 217 0058 20E8      		ldi r18,lo8(-128)
 218               	/* #APP */
 219               	 ;  30 "main.c" 1
 220 005a 0FB6      		in __tmp_reg__,__SREG__
 221 005c F894      		cli
 222 005e 2093 6100 		sts 97, r18
 223 0062 8093 6100 		sts 97, r24
 224 0066 0FBE      		out __SREG__, __tmp_reg__
 225               	 ;  0 "" 2
 226               	/* #NOAPP */
 227               	.LBE30:
 228               	.LBE29:
 229               	.LBE28:
 231               	.LM11:
 232 0068 0E94 0000 		call joy_init
 234               	.LM12:
 235 006c 0E94 0000 		call usart_init
 237               	.LM13:
 238 0070 0E94 0000 		call adc_init
 240               	.LM14:
 241 0074 0E94 0000 		call timers_init
 243               	.LM15:
 244 0078 0E94 0000 		call motors_init
 246               	.LM16:
 247               	/* #APP */
 248               	 ;  54 "main.c" 1
 249 007c 7894      		sei
 250               	 ;  0 "" 2
 252               	.LM17:
 253               	/* #NOAPP */
 254 007e 80E0      		ldi r24,lo8(__c.1593)
 255 0080 90E0      		ldi r25,hi8(__c.1593)
 256 0082 9F93      		push r25
 257 0084 8F93      		push r24
 258 0086 0E94 0000 		call printf_P
 259 008a 0F90      		pop __tmp_reg__
 260 008c 0F90      		pop __tmp_reg__
 261               	/* epilogue start */
 263               	.LM18:
 264 008e 0895      		ret
 266               	.Lscope3:
 268               		.stabd	78,0,0
 270               	.global	main
 272               	main:
 273               		.stabd	46,0,0
 275               	.LM19:
 276               	.LFBB4:
 277               	/* prologue: function */
 278               	/* frame size = 0 */
 280               	.LM20:
 281 0090 0E94 0000 		call init
 283               	.LM21:
 284 0094 1092 0000 		sts c_mode,__zero_reg__
 286               	.LM22:
 287 0098 81E0      		ldi r24,lo8(1)
 288 009a 8093 0000 		sts initial,r24
 289               	.L8:
 290 009e 00C0      		rjmp .L8
 292               	.Lscope4:
 294               		.stabd	78,0,0
 297               	.global	print_bin
 299               	print_bin:
 300               		.stabd	46,0,0
 302               	.LM23:
 303               	.LFBB5:
 304 00a0 EF92      		push r14
 305 00a2 FF92      		push r15
 306 00a4 0F93      		push r16
 307 00a6 1F93      		push r17
 308 00a8 CF93      		push r28
 309 00aa DF93      		push r29
 310               	/* prologue: function */
 311               	/* frame size = 0 */
 313               	.LM24:
 314 00ac C7E0      		ldi r28,lo8(7)
 315 00ae D0E0      		ldi r29,hi8(7)
 316               	.LBB31:
 318               	.LM25:
 319 00b0 91E0      		ldi r25,lo8(1)
 320 00b2 E92E      		mov r14,r25
 321 00b4 F12C      		mov r15,__zero_reg__
 322 00b6 082F      		mov r16,r24
 323 00b8 10E0      		ldi r17,lo8(0)
 324               	.L11:
 325 00ba C701      		movw r24,r14
 326 00bc 0C2E      		mov r0,r28
 327 00be 00C0      		rjmp 2f
 328 00c0 880F      	1:	lsl r24
 329 00c2 991F      		rol r25
 330 00c4 0A94      	2:	dec r0
 331 00c6 02F4      		brpl 1b
 332 00c8 8023      		and r24,r16
 333 00ca 9123      		and r25,r17
 334 00cc 0C2E      		mov r0,r28
 335 00ce 00C0      		rjmp 2f
 336 00d0 9595      	1:	asr r25
 337 00d2 8795      		ror r24
 338 00d4 0A94      	2:	dec r0
 339 00d6 02F4      		brpl 1b
 340 00d8 C096      		adiw r24,48
 341 00da 0E94 0000 		call putchar
 342 00de 2197      		sbiw r28,1
 344               	.LM26:
 345 00e0 8FEF      		ldi r24,hi8(-1)
 346 00e2 CF3F      		cpi r28,lo8(-1)
 347 00e4 D807      		cpc r29,r24
 348 00e6 01F4      		brne .L11
 349               	/* epilogue start */
 350               	.LBE31:
 352               	.LM27:
 353 00e8 DF91      		pop r29
 354 00ea CF91      		pop r28
 355 00ec 1F91      		pop r17
 356 00ee 0F91      		pop r16
 357 00f0 FF90      		pop r15
 358 00f2 EF90      		pop r14
 359 00f4 0895      		ret
 361               	.Lscope5:
 363               		.stabd	78,0,0
 364               		.section	.progmem.data,"a",@progbits
 367               	__c.1640:
 368 0000 0A0A 496E 		.string	"\n\nInvalid Interupt Enabled\n"
 368      7661 6C69 
 368      6420 496E 
 368      7465 7275 
 368      7074 2045 
 371               	__c.1593:
 372 001c 0A49 6E69 		.string	"\nInit: Done\n\n"
 372      743A 2044 
 372      6F6E 650A 
 372      0A00 
 373               		.comm c_mode,1,1
 374               		.comm initial,1,1
 375               		.comm adc_val,8,1
 376               		.comm adc_offset,8,1
 377               		.comm adc_amt,8,1
 378               		.comm curr_ch,1,1
 387               		.text
 389               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cc1N3fI2.s:2      *ABS*:0000003f __SREG__
     /tmp/cc1N3fI2.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc1N3fI2.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc1N3fI2.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cc1N3fI2.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cc1N3fI2.s:110    .text:00000000 clock_init
     /tmp/cc1N3fI2.s:144    .text:00000016 __vector_default
     /tmp/cc1N3fI2.s:367    .progmem.data:00000000 __c.1640
     /tmp/cc1N3fI2.s:184    .text:00000042 init
     /tmp/cc1N3fI2.s:371    .progmem.data:0000001c __c.1593
     /tmp/cc1N3fI2.s:272    .text:00000090 main
                            *COM*:00000001 c_mode
                            *COM*:00000001 initial
     /tmp/cc1N3fI2.s:299    .text:000000a0 print_bin
                            *COM*:00000008 adc_val
                            *COM*:00000008 adc_offset
                            *COM*:00000008 adc_amt
                            *COM*:00000001 curr_ch

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
printf_P
joy_init
usart_init
adc_init
timers_init
motors_init
putchar
