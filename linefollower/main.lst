   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 116               	.global	clock_init
 118               	clock_init:
 119               		.stabd	46,0,0
   1:main.c        **** /*
   2:main.c        **** //Follow the damn line
   3:main.c        **** char Author [] ="Cody Schafer";
   4:main.c        **** */
   5:main.c        **** 
   6:main.c        **** #include <stdbool.h>
   7:main.c        **** #include "defines.h"
   8:main.c        **** #include "usart.h"
   9:main.c        **** #include "adc.h"
  10:main.c        **** #include "motor.h"
  11:main.c        **** #include "timers.h"
  12:main.c        **** #include "joystick.h"
  13:main.c        **** #include <avr/power.h>
  14:main.c        **** #include <stdio.h>
  15:main.c        **** #include <avr/io.h>
  16:main.c        **** #include <avr/interrupt.h>
  17:main.c        **** #include <util/delay.h>
  18:main.c        **** #include <avr/pgmspace.h>
  19:main.c        **** #include <stdlib.h>
  20:main.c        **** 
  21:main.c        **** 
  22:main.c        **** void clock_init(void) {
 121               	.LM0:
 122               	.LFBB1:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	.LBB27:
  23:main.c        **** 	
  24:main.c        **** 	#if   F_CPU == 1000000
  25:main.c        **** 		clock_prescale_set(clock_div_8);	
  26:main.c        **** 	#elif F_CPU == 2000000
  27:main.c        **** 		clock_prescale_set(clock_div_4);	
  28:main.c        **** 	#elif F_CPU == 4000000
  29:main.c        **** 		clock_prescale_set(clock_div_2);	
  30:main.c        **** 	#elif F_CPU == 8000000
  31:main.c        **** 		clock_prescale_set(clock_div_1);	
 127               	.LM1:
 128 0000 80E0      		ldi r24,lo8(0)
 129 0002 90E0      		ldi r25,hi8(0)
 130 0004 20E8      		ldi r18,lo8(-128)
 131               	/* #APP */
 132               	 ;  31 "main.c" 1
 133 0006 0FB6      		in __tmp_reg__,__SREG__
 134 0008 F894      		cli
 135 000a 2093 6100 		sts 97, r18
 136 000e 8093 6100 		sts 97, r24
 137 0012 0FBE      		out __SREG__, __tmp_reg__
 138               	 ;  0 "" 2
 139               	/* epilogue start */
 140               	/* #NOAPP */
 141               	.LBE27:
  32:main.c        **** 	#else
  33:main.c        **** 		#error "F_CPU Unrecognized"
  34:main.c        **** 	#endif
  35:main.c        **** 	
  36:main.c        **** 	//OSCAL set by the bootloader.
  37:main.c        **** }
 143               	.LM2:
 144 0014 0895      		ret
 146               	.Lscope1:
 148               		.stabd	78,0,0
 150               	.global	__vector_default
 152               	__vector_default:
 153               		.stabd	46,0,0
  38:main.c        **** 
  39:main.c        **** void  print_bin(uint8_t inp) {
  40:main.c        **** 	for(int8_t j=7; j>=0; --j) {
  41:main.c        **** 	   	printf("%c",((inp&(1<<j))>>j)+'0');
  42:main.c        **** 	}
  43:main.c        **** }
  44:main.c        **** 
  45:main.c        **** void init(void) {
  46:main.c        **** 	cli(); // Starts with interrupts disabled?
  47:main.c        **** 	power_all_disable();
  48:main.c        **** 	clock_init();
  49:main.c        **** 	joy_init();
  50:main.c        **** 	usart_init();
  51:main.c        **** 	adc_init();
  52:main.c        **** 	timers_init();
  53:main.c        **** 	motors_init();
  54:main.c        **** 	sei();
  55:main.c        **** 	#ifdef debug
  56:main.c        **** 	printf_P(PSTR("\nInit: Done\n\n"));
  57:main.c        **** 	#endif
  58:main.c        **** }
  59:main.c        **** 
  60:main.c        **** 
  61:main.c        **** 
  62:main.c        **** int main(void) {
  63:main.c        **** 	init();
  64:main.c        **** 	c_mode=WAIT;
  65:main.c        **** 	initial=true;
  66:main.c        **** 	
  67:main.c        **** 		
  68:main.c        **** 	for(;;) {
  69:main.c        **** 		if	(c_mode==FOLLOW) {	
  70:main.c        **** 			if (initial) {
  71:main.c        **** 				lf_full_speed();
  72:main.c        **** 				initial=false;
  73:main.c        **** 			}
  74:main.c        **** //			uint16_t c_speed [2] = {motor_get_speed(LEFT),motor_get_speed(RIGHT)};
  75:main.c        **** 
  76:main.c        **** 			uint16_t adc_vc[channel_amt];
  77:main.c        **** 			for (uint8_t i=0;i<channel_amt;++i) {
  78:main.c        **** 				adc_vc[i]=adc_get_val(i);
  79:main.c        **** 			}
  80:main.c        **** 			
  81:main.c        **** 			uint8_t  maxi=channel_amt;
  82:main.c        **** 			uint16_t maxv=0;
  83:main.c        **** 			for (uint8_t i=0;i<channel_amt;++i) {
  84:main.c        **** 				if (adc_vc[i]>maxv) {
  85:main.c        **** 					maxi=i;
  86:main.c        **** 					maxv=adc_vc[i];
  87:main.c        **** 				}
  88:main.c        **** 			}
  89:main.c        **** 			
  90:main.c        **** 			#ifdef debug
  91:main.c        **** 			print_adc_values();
  92:main.c        **** 			printf_P(PSTR("\nMax Channel [L 0 1 2 3 R]: %d;v=%d"),maxi,maxv);
  93:main.c        **** 			#endif
  94:main.c        **** 
  95:main.c        **** 			int8_t turn_i;			
  96:main.c        **** 			turn_i = maxi-channel_amt/2; // Needs to work for even numbers....
  97:main.c        **** 			
  98:main.c        **** 			// Correction needed for even numbers of sensors.
  99:main.c        **** 			#if (!(channel_amt%2))
 100:main.c        **** 			if (turn_i>0)
 101:main.c        **** 				++turn_i;	
 102:main.c        **** 			#endif
 103:main.c        **** 
 104:main.c        **** 			lf_turn_inc(abs(LF_INC_SMALL*turn_i),turn_i>=0);
 105:main.c        **** 			
 106:main.c        **** 			
 107:main.c        **** 			//0=LEFT, 3=RIGHT
 108:main.c        **** 			/*
 109:main.c        **** 			if		((adc_vc[0]>adc_vc[1])&&(adc_vc[0]>adc_vc[2])&&(adc_vc[0]>adc_vc[3])) {
 110:main.c        **** 				lf_turn_inc(LF_INC_LARGE,NEG);
 111:main.c        **** 				dir=LEFT;
 112:main.c        **** 			}
 113:main.c        **** 			else if ((adc_vc[3]>adc_vc[0])&&(adc_vc[3]>adc_vc[1])&&(adc_vc[3]>adc_vc[2])) {
 114:main.c        **** 				lf_turn_inc(LF_INC_LARGE,POS);
 115:main.c        **** 				dir=RIGHT;
 116:main.c        **** 			}
 117:main.c        **** 			else if	((adc_vc[2]>adc_vc[0])&&(adc_vc[2]>adc_vc[1])&&(adc_vc[2]>adc_vc[3])) {
 118:main.c        **** 				lf_turn_inc(LF_INC_SMALL,NEG);
 119:main.c        **** 				dir=LEFT;
 120:main.c        **** 			}
 121:main.c        **** 			else if ((adc_vc[1]>adc_vc[0])&&(adc_vc[1]>adc_vc[2])&&(adc_vc[1]>adc_vc[3])) {
 122:main.c        **** 				lf_turn_inc(LF_INC_LARGE,POS);
 123:main.c        **** 				dir=RIGHT;
 124:main.c        **** 			}
 125:main.c        **** 			else if ((adc_vc[0]<adc_vc[1])&&(adc_vc[2]>adc_vc[3])) {
 126:main.c        **** 				//lf_full_speed();
 127:main.c        **** 				dir=FWD;
 128:main.c        **** 			}
 129:main.c        **** 			else if ((adc_vc[0]==adc_vc[1])&&(adc_vc[1]==adc_vc[2])&&(adc_vc[2]==adc_vc[3])){
 130:main.c        **** 				//lf_full_speed();
 131:main.c        **** 				dir=FWD;
 132:main.c        **** 			}
 133:main.c        **** 			*/
 134:main.c        **** 
 135:main.c        **** 			_delay_ms(200);
 136:main.c        **** 			// do at every adc calc or pwm vector.
 137:main.c        **** 		}
 138:main.c        **** 		else if	(c_mode==TEST) {
 139:main.c        **** 			if (initial) {
 140:main.c        **** 				motor_mode(MOTOR_L_FWD,LEFT);
 141:main.c        **** 				motor_mode(MOTOR_R_FWD,RIGHT);
 142:main.c        **** 				initial=false;
 143:main.c        **** 			}
 144:main.c        **** 			static uint16_t sp;
 145:main.c        **** 			
 146:main.c        **** 			motor_set_speed(sp,LEFT);
 147:main.c        **** 			motor_set_speed(sp,RIGHT);
 148:main.c        **** 			_delay_ms(2);
 149:main.c        **** 			//if (!(sp%0x100))
 150:main.c        **** 			//	printf("\nsp=%x",sp);
 151:main.c        **** 			++sp;
 152:main.c        **** 		}
 153:main.c        **** 	}	
 154:main.c        **** } 
 155:main.c        **** 		
 156:main.c        **** ISR(BADISR_vect) {
 155               	.LM3:
 156               	.LFBB2:
 157 0016 1F92      		push __zero_reg__
 158 0018 0F92      		push r0
 159 001a 0FB6      		in r0,__SREG__
 160 001c 0F92      		push r0
 161 001e 1124      		clr __zero_reg__
 162 0020 8F93      		push r24
 163 0022 9F93      		push r25
 164               	/* prologue: Signal */
 165               	/* frame size = 0 */
 157:main.c        **** 	fprintf_P(stderr,PSTR("\n\nInvalid Interupt Enabled\n"));
 167               	.LM4:
 168 0024 80E0      		ldi r24,lo8(__c.1747)
 169 0026 90E0      		ldi r25,hi8(__c.1747)
 170 0028 9F93      		push r25
 171 002a 8F93      		push r24
 172 002c 8091 0000 		lds r24,__iob+4
 173 0030 9091 0000 		lds r25,(__iob+4)+1
 174 0034 9F93      		push r25
 175 0036 8F93      		push r24
 176 0038 0E94 0000 		call fprintf_P
 177 003c 0F90      		pop __tmp_reg__
 178 003e 0F90      		pop __tmp_reg__
 179 0040 0F90      		pop __tmp_reg__
 180 0042 0F90      		pop __tmp_reg__
 181               	/* epilogue start */
 158:main.c        **** }
 183               	.LM5:
 184 0044 9F91      		pop r25
 185 0046 8F91      		pop r24
 186 0048 0F90      		pop r0
 187 004a 0FBE      		out __SREG__,r0
 188 004c 0F90      		pop r0
 189 004e 1F90      		pop __zero_reg__
 190 0050 1895      		reti
 192               	.Lscope2:
 194               		.stabd	78,0,0
 196               	.global	init
 198               	init:
 199               		.stabd	46,0,0
 201               	.LM6:
 202               	.LFBB3:
 203               	/* prologue: function */
 204               	/* frame size = 0 */
 206               	.LM7:
 207               	/* #APP */
 208               	 ;  46 "main.c" 1
 209 0052 F894      		cli
 210               	 ;  0 "" 2
 212               	.LM8:
 213               	/* #NOAPP */
 214 0054 E4E6      		ldi r30,lo8(100)
 215 0056 F0E0      		ldi r31,hi8(100)
 216 0058 8081      		ld r24,Z
 217 005a 8F61      		ori r24,lo8(31)
 218 005c 8083      		st Z,r24
 219               	.LBB28:
 220               	.LBB29:
 221               	.LBB30:
 223               	.LM9:
 224 005e 80E0      		ldi r24,lo8(0)
 225 0060 90E0      		ldi r25,hi8(0)
 226 0062 20E8      		ldi r18,lo8(-128)
 227               	/* #APP */
 228               	 ;  31 "main.c" 1
 229 0064 0FB6      		in __tmp_reg__,__SREG__
 230 0066 F894      		cli
 231 0068 2093 6100 		sts 97, r18
 232 006c 8093 6100 		sts 97, r24
 233 0070 0FBE      		out __SREG__, __tmp_reg__
 234               	 ;  0 "" 2
 235               	/* #NOAPP */
 236               	.LBE30:
 237               	.LBE29:
 238               	.LBE28:
 240               	.LM10:
 241 0072 0E94 0000 		call joy_init
 243               	.LM11:
 244 0076 0E94 0000 		call usart_init
 246               	.LM12:
 247 007a 0E94 0000 		call adc_init
 249               	.LM13:
 250 007e 0E94 0000 		call timers_init
 252               	.LM14:
 253 0082 0E94 0000 		call motors_init
 255               	.LM15:
 256               	/* #APP */
 257               	 ;  54 "main.c" 1
 258 0086 7894      		sei
 259               	 ;  0 "" 2
 261               	.LM16:
 262               	/* #NOAPP */
 263 0088 80E0      		ldi r24,lo8(__c.1702)
 264 008a 90E0      		ldi r25,hi8(__c.1702)
 265 008c 9F93      		push r25
 266 008e 8F93      		push r24
 267 0090 0E94 0000 		call printf_P
 268 0094 0F90      		pop __tmp_reg__
 269 0096 0F90      		pop __tmp_reg__
 270               	/* epilogue start */
 272               	.LM17:
 273 0098 0895      		ret
 275               	.Lscope3:
 277               		.stabd	78,0,0
 279               	.global	main
 281               	main:
 282               		.stabd	46,0,0
 284               	.LM18:
 285               	.LFBB4:
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 289               	.LM19:
 290 009a 0E94 0000 		call init
 292               	.LM20:
 293 009e 1092 0000 		sts c_mode,__zero_reg__
 295               	.LM21:
 296 00a2 81E0      		ldi r24,lo8(1)
 297 00a4 8093 0000 		sts initial,r24
 298               	.L8:
 299 00a8 00C0      		rjmp .L8
 301               	.Lscope4:
 303               		.stabd	78,0,0
 306               	.global	print_bin
 308               	print_bin:
 309               		.stabd	46,0,0
 311               	.LM22:
 312               	.LFBB5:
 313 00aa EF92      		push r14
 314 00ac FF92      		push r15
 315 00ae 0F93      		push r16
 316 00b0 1F93      		push r17
 317 00b2 CF93      		push r28
 318 00b4 DF93      		push r29
 319               	/* prologue: function */
 320               	/* frame size = 0 */
 322               	.LM23:
 323 00b6 C7E0      		ldi r28,lo8(7)
 324 00b8 D0E0      		ldi r29,hi8(7)
 325               	.LBB31:
 327               	.LM24:
 328 00ba 91E0      		ldi r25,lo8(1)
 329 00bc E92E      		mov r14,r25
 330 00be F12C      		mov r15,__zero_reg__
 331 00c0 082F      		mov r16,r24
 332 00c2 10E0      		ldi r17,lo8(0)
 333               	.L11:
 334 00c4 C701      		movw r24,r14
 335 00c6 0C2E      		mov r0,r28
 336 00c8 00C0      		rjmp 2f
 337 00ca 880F      	1:	lsl r24
 338 00cc 991F      		rol r25
 339 00ce 0A94      	2:	dec r0
 340 00d0 02F4      		brpl 1b
 341 00d2 8023      		and r24,r16
 342 00d4 9123      		and r25,r17
 343 00d6 0C2E      		mov r0,r28
 344 00d8 00C0      		rjmp 2f
 345 00da 9595      	1:	asr r25
 346 00dc 8795      		ror r24
 347 00de 0A94      	2:	dec r0
 348 00e0 02F4      		brpl 1b
 349 00e2 C096      		adiw r24,48
 350 00e4 0E94 0000 		call putchar
 351 00e8 2197      		sbiw r28,1
 353               	.LM25:
 354 00ea 8FEF      		ldi r24,hi8(-1)
 355 00ec CF3F      		cpi r28,lo8(-1)
 356 00ee D807      		cpc r29,r24
 357 00f0 01F4      		brne .L11
 358               	/* epilogue start */
 359               	.LBE31:
 361               	.LM26:
 362 00f2 DF91      		pop r29
 363 00f4 CF91      		pop r28
 364 00f6 1F91      		pop r17
 365 00f8 0F91      		pop r16
 366 00fa FF90      		pop r15
 367 00fc EF90      		pop r14
 368 00fe 0895      		ret
 370               	.Lscope5:
 372               		.stabd	78,0,0
 373               		.section	.progmem.data,"a",@progbits
 376               	__c.1747:
 377 0000 0A0A 496E 		.string	"\n\nInvalid Interupt Enabled\n"
 377      7661 6C69 
 377      6420 496E 
 377      7465 7275 
 377      7074 2045 
 380               	__c.1702:
 381 001c 0A49 6E69 		.string	"\nInit: Done\n\n"
 381      743A 2044 
 381      6F6E 650A 
 381      0A00 
 382               		.comm c_mode,1,1
 383               		.comm initial,1,1
 384               		.comm adc_val,8,1
 385               		.comm adc_offset,8,1
 386               		.comm adc_amt,8,1
 387               		.comm curr_ch,1,1
 396               		.text
 398               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cck9ci4f.s:2      *ABS*:0000003f __SREG__
     /tmp/cck9ci4f.s:3      *ABS*:0000003e __SP_H__
     /tmp/cck9ci4f.s:4      *ABS*:0000003d __SP_L__
     /tmp/cck9ci4f.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cck9ci4f.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cck9ci4f.s:118    .text:00000000 clock_init
     /tmp/cck9ci4f.s:152    .text:00000016 __vector_default
     /tmp/cck9ci4f.s:376    .progmem.data:00000000 __c.1747
     /tmp/cck9ci4f.s:198    .text:00000052 init
     /tmp/cck9ci4f.s:380    .progmem.data:0000001c __c.1702
     /tmp/cck9ci4f.s:281    .text:0000009a main
                            *COM*:00000001 c_mode
                            *COM*:00000001 initial
     /tmp/cck9ci4f.s:308    .text:000000aa print_bin
                            *COM*:00000008 adc_val
                            *COM*:00000008 adc_offset
                            *COM*:00000008 adc_amt
                            *COM*:00000001 curr_ch

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__iob
fprintf_P
joy_init
usart_init
adc_init
timers_init
motors_init
printf_P
putchar
