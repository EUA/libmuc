   1               		.file	"timers.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 104               	.global	__vector_9
 106               	__vector_9:
 107               		.stabd	46,0,0
   1:timers.c      **** /* 
   2:timers.c      ****  * File: timers.c
   3:timers.c      ****  * Function: control of timers and pwm outputs
   4:timers.c      ****  */
   5:timers.c      **** 
   6:timers.c      **** #include "adc.h"
   7:timers.c      **** #include "defines.h"
   8:timers.c      **** #include <util/atomic.h>
   9:timers.c      **** #include <avr/io.h>
  10:timers.c      **** #include <avr/interrupt.h>
  11:timers.c      **** #include <stdio.h>
  12:timers.c      **** #include <avr/pgmspace.h>
  13:timers.c      **** #include <avr/power.h>
  14:timers.c      **** 
  15:timers.c      **** 
  16:timers.c      **** void timer2_init(void) {
  17:timers.c      **** 	#ifdef debug
  18:timers.c      **** 	fprintf_P(stderr,PSTR("\ntimers: init: timer2"));
  19:timers.c      **** 	#endif
  20:timers.c      **** 	//power_timer2_enable(); // can't be disabled in m169p
  21:timers.c      **** 	
  22:timers.c      **** 	// External crystal : 32.768KHZ
  23:timers.c      **** 	/*
  24:timers.c      **** 	a. Disable the Timer/Counter2 interrupts by clearing OCIE2A and TOIE2.
  25:timers.c      **** 	b. Select clock source by setting AS2 as appropriate.
  26:timers.c      **** 	c. Write new values to TCNT2, OCR2A, and TCCR2A.
  27:timers.c      **** 	d. To switch to asynchronous operation: Wait for TCN2UB, OCR2UB, and TCR2UB.
  28:timers.c      **** 	e. Clear the Timer/Counter2 Interrupt Flags.
  29:timers.c      **** 	f. Enable interrupts, if needed.
  30:timers.c      **** 	*/
  31:timers.c      **** 	
  32:timers.c      **** 	// disable interupts (probably alread done)
  33:timers.c      **** 	TIMSK2&=(uint8_t)~((1<<OCIE2A)|(1<<TOIE2));
  34:timers.c      **** 	
  35:timers.c      **** 	// Enable asyncronous clocking.
  36:timers.c      **** 	ASSR&=(uint8_t)~(1<<EXCLK);
  37:timers.c      **** 	ASSR|=(uint8_t)(1<<AS2);
  38:timers.c      **** 	
  39:timers.c      **** 	// Reset acculumator
  40:timers.c      **** 	TCNT2 = 0;
  41:timers.c      **** 	
  42:timers.c      **** 	TCCR2A&=(uint8_t)~(1<<FOC2A);
  43:timers.c      **** 	
  44:timers.c      **** 	/* 	Mode	WGM21	WGM20	operation
  45:timers.c      **** 		0	0		0		Normal
  46:timers.c      **** 		1	0		1		PWM,Phase correct
  47:timers.c      **** 		2	1		0		CTC
  48:timers.c      **** 		3	1		1		Fast PWM
  49:timers.c      **** 	*/
  50:timers.c      **** 	// : CTC Mode.
  51:timers.c      **** 	//TCCR2A|=(1<<WGM20);
  52:timers.c      **** 	//TCCR2A&=~(1<<WGM21);
  53:timers.c      **** 	// : Normal Mode.
  54:timers.c      **** 	TCCR2A&=(uint8_t)~((1<<WGM20)|(1<<WGM21));
  55:timers.c      **** 	
  56:timers.c      **** 	/* Compare output mode (non-pwm) (OC2A)
  57:timers.c      **** 		COM2A1	COM2A0	Result
  58:timers.c      **** 		0		0		No output
  59:timers.c      **** 		0		1		Toggle on compare match
  60:timers.c      **** 		1		0		clear on compare match
  61:timers.c      **** 		1		1		set on 		"		"
  62:timers.c      **** 	*/
  63:timers.c      **** 	// : No output
  64:timers.c      **** 	TCCR2A&=(uint8_t)~((1<<COM2A1)|(1<<COM2A0));
  65:timers.c      **** 	
  66:timers.c      **** 	// Clock Select (Prescale) set
  67:timers.c      **** 
  68:timers.c      **** 	//32768/1/256 = 128Hz
  69:timers.c      **** 	//TCCR2A&=~((1<<CS22)|(1<<CS21));
  70:timers.c      **** 	//TCCR2A|= (1<<CS20);
  71:timers.c      **** 	
  72:timers.c      **** 	// 32768/8/256 = 16Hz
  73:timers.c      **** 	//TCCR2A|= (uint8_t)(1<<CS21);
  74:timers.c      **** 	//TCCR2A&=(uint8_t)~((uint8_t)((1<<CS20)|(1<<CS22)));
  75:timers.c      **** 
  76:timers.c      **** 	// 32768/128/256 = 1Hz
  77:timers.c      **** 	TCCR2A|= (1<<CS20)|(1<<CS22);
  78:timers.c      **** 	TCCR2A&=(uint8_t)~(1<<CS21);
  79:timers.c      **** 
  80:timers.c      **** 	// 32768/1024/256 = 1/8Hz
  81:timers.c      **** 	//TCCR2A|= (1<<CS21)|(1<<CS20)|(1<<CS22);
  82:timers.c      **** 
  83:timers.c      **** 	loop_until_bit_is_clear(ASSR,TCN2UB);
  84:timers.c      **** 	loop_until_bit_is_clear(ASSR,OCR2UB);
  85:timers.c      **** 	loop_until_bit_is_clear(ASSR,TCR2UB);
  86:timers.c      **** 	
  87:timers.c      **** 	// Enable overflow interrupt, disable match.
  88:timers.c      **** 	//TIMSK2|= (1<<TOIE2);
  89:timers.c      **** 	//TIMSK2&=~(1<<OCIE2A); // Disabled
  90:timers.c      **** 	#ifdef debug
  91:timers.c      **** 	fprintf_P(stderr,PSTR("\t[done]"));
  92:timers.c      **** 	#endif
  93:timers.c      **** }
  94:timers.c      **** 
  95:timers.c      **** 
  96:timers.c      **** // Timer2 Overflow
  97:timers.c      **** ISR(TIMER2_OVF_vect) {
  98:timers.c      **** 	static uint16_t sec;//=0
  99:timers.c      **** 	++sec;
 100:timers.c      **** 	if (c_mode==WAIT) {
 101:timers.c      **** 		//printf("\n\tT: %ds\n",sec);
 102:timers.c      **** 		#ifdef debug
 103:timers.c      **** 		fprintf_P(stderr,PSTR("\nMode: %d"),c_mode);
 104:timers.c      **** 		#endif
 105:timers.c      **** 	}
 106:timers.c      **** 
 107:timers.c      **** }
 108:timers.c      **** 
 109:timers.c      **** void timer1_init(void) { // Runs the PWMs
 110:timers.c      **** 	#ifdef debug
 111:timers.c      **** 	fprintf_P(stderr,PSTR("\ntimers: init: timer1"));
 112:timers.c      **** 	#endif
 113:timers.c      **** 	power_timer1_enable();
 114:timers.c      **** 	// Set OC1A/B on up, clear on down
 115:timers.c      **** //	TCCR1A|= (1<<COM1A1)|(1<<COM1A0);
 116:timers.c      **** //	TCCR1A|= (1<<COM1B1)|(1<<COM1B0);
 117:timers.c      **** 
 118:timers.c      **** 	// OC1A/B disconnected
 119:timers.c      **** 	TCCR1A&= (uint8_t) ~((1<<COM1A1)|(1<<COM1A0)|(1<<COM1B1)|(1<<COM1B0));
 120:timers.c      **** 	
 121:timers.c      **** 	// Waveform Generation Set to PWM (Phase and frequency correct, mode 8)
 122:timers.c      **** 	//TCCR1A&= (uint8_t) ~((1<<WGM11)|(1<<WGM10));
 123:timers.c      **** 	
 124:timers.c      **** 	// Phase correct only
 125:timers.c      **** 	TCCR1A|= (1<<WGM11);
 126:timers.c      **** 	TCCR1A&= (uint8_t) ~(1<<WGM11);
 127:timers.c      **** 	
 128:timers.c      **** 	TCCR1B|= (uint8_t) (1<<5); //Reserved bit
 129:timers.c      **** 	TCCR1B|= (uint8_t) (1<<WGM13);
 130:timers.c      **** 	TCCR1B&= (uint8_t)~(1<<WGM12);
 131:timers.c      **** 
 132:timers.c      **** 	// Disable Input noise canceler
 133:timers.c      **** 	TCCR1B&= (uint8_t)~(1<<ICNC1);
 134:timers.c      **** 	
 135:timers.c      **** 	// Set TOP
 136:timers.c      **** 	ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 137:timers.c      **** 		ICR1=0xFFFF;
 138:timers.c      **** 	}
 139:timers.c      **** 	
 140:timers.c      **** 	// Note: f[OCnxPFCPWM]=f[pwm]=f[clk_io]/(2*Prescale*TOP);
 141:timers.c      **** 	//	Presacle = f[clk]/(2*f[pwm]*TOP)
 142:timers.c      **** 	//	Max f[pwm] for TB6612FNG is 100KHz (100000HZ)
 143:timers.c      **** 	//prescale = F_CPU/(2*100000*0xFFFF) = 
 144:timers.c      **** 	// At 8MHz the best we get is 60Hz (bad. very bad.)
 145:timers.c      **** 	
 146:timers.c      **** 	// Set prescale to 1
 147:timers.c      **** 	// TCCR1B = (TCCR1B & 0b11111000)|(log(prescale)/log(2));
 148:timers.c      **** 	TCCR1B&= (uint8_t)~((1<<CS12)|(1<<CS11));
 149:timers.c      **** 	TCCR1B|= (uint8_t) (1<<CS10);
 150:timers.c      **** 	
 151:timers.c      **** 	//OCR1A and OCR1B are the Compare / PWM registers
 152:timers.c      **** 	//OCR1A = OCR1B = 0xFFFF; // Max = 65535,0xFFFF
 153:timers.c      **** 	
 154:timers.c      **** 	// Enable the interupts, used to avoid the fucking speaker.
 155:timers.c      **** 	TIMSK1|=((1<<OCIE1B)|(1<<OCIE1A)|(1<<TOIE1));
 156:timers.c      **** 	
 157:timers.c      **** 	MOTOR_PWM_DDR|= ((1<<M_PWMA_PIN)|(1<<M_PWMB_PIN));
 158:timers.c      **** 	#ifdef debug
 159:timers.c      **** 	fprintf_P(stderr,PSTR("\t[done]"));
 160:timers.c      **** 	#endif
 161:timers.c      **** }
 162:timers.c      **** 
 163:timers.c      **** enum {DOWN, UP};
 164:timers.c      **** static uint8_t timer_2_dir;
 165:timers.c      **** /* Timer/Counter1 Overflow ; BOTTOM */
 166:timers.c      **** ISR(TIMER1_OVF_vect) {
 109               	.LM0:
 110               	.LFBB1:
 111 0000 1F92      		push __zero_reg__
 112 0002 0F92      		push r0
 113 0004 0FB6      		in r0,__SREG__
 114 0006 0F92      		push r0
 115 0008 1124      		clr __zero_reg__
 116 000a 8F93      		push r24
 117               	/* prologue: Signal */
 118               	/* frame size = 0 */
 167:timers.c      **** 	timer_2_dir=UP;
 120               	.LM1:
 121 000c 81E0      		ldi r24,lo8(1)
 122 000e 8093 0000 		sts timer_2_dir,r24
 123               	/* epilogue start */
 168:timers.c      **** }
 125               	.LM2:
 126 0012 8F91      		pop r24
 127 0014 0F90      		pop r0
 128 0016 0FBE      		out __SREG__,r0
 129 0018 0F90      		pop r0
 130 001a 1F90      		pop __zero_reg__
 131 001c 1895      		reti
 133               	.Lscope1:
 135               		.stabd	78,0,0
 137               	.global	__vector_6
 139               	__vector_6:
 140               		.stabd	46,0,0
 169:timers.c      **** 
 170:timers.c      **** /* Timer/Counter1 ISR1 ; TOP */
 171:timers.c      **** ISR(SIG_INPUT_CAPTURE1) {
 142               	.LM3:
 143               	.LFBB2:
 144 001e 1F92      		push __zero_reg__
 145 0020 0F92      		push r0
 146 0022 0FB6      		in r0,__SREG__
 147 0024 0F92      		push r0
 148 0026 1124      		clr __zero_reg__
 149               	/* prologue: Signal */
 150               	/* frame size = 0 */
 172:timers.c      **** 	timer_2_dir=DOWN;
 152               	.LM4:
 153 0028 1092 0000 		sts timer_2_dir,__zero_reg__
 154               	/* epilogue start */
 173:timers.c      **** }
 156               	.LM5:
 157 002c 0F90      		pop r0
 158 002e 0FBE      		out __SREG__,r0
 159 0030 0F90      		pop r0
 160 0032 1F90      		pop __zero_reg__
 161 0034 1895      		reti
 163               	.Lscope2:
 165               		.stabd	78,0,0
 167               	.global	__vector_7
 169               	__vector_7:
 170               		.stabd	46,0,0
 174:timers.c      **** 
 175:timers.c      **** static char dirtoc(uint8_t dir){
 176:timers.c      **** 	if (dir==UP)
 177:timers.c      **** 		return 'U';
 178:timers.c      **** 	else if (dir==DOWN)
 179:timers.c      **** 		return 'D';
 180:timers.c      **** 	else
 181:timers.c      **** 		return '?';
 182:timers.c      **** }
 183:timers.c      **** 
 184:timers.c      **** 
 185:timers.c      **** /* Timer/Counter Compare Match A */
 186:timers.c      **** ISR(TIMER1_COMPA_vect) {
 172               	.LM6:
 173               	.LFBB3:
 174 0036 1F92      		push __zero_reg__
 175 0038 0F92      		push r0
 176 003a 0FB6      		in r0,__SREG__
 177 003c 0F92      		push r0
 178 003e 1124      		clr __zero_reg__
 179 0040 8F93      		push r24
 180               	/* prologue: Signal */
 181               	/* frame size = 0 */
 187:timers.c      **** 	if (timer_2_dir==UP)	
 183               	.LM7:
 184 0042 8091 0000 		lds r24,timer_2_dir
 185 0046 8130      		cpi r24,lo8(1)
 186 0048 01F4      		brne .L6
 188:timers.c      **** 		MOTOR_PWM_PORT&=(uint8_t)~(1<<M_PWMA_PIN);
 188               	.LM8:
 189 004a 2A98      		cbi 37-0x20,2
 190 004c 00C0      		rjmp .L8
 191               	.L6:
 189:timers.c      **** 	else
 190:timers.c      **** 		MOTOR_PWM_PORT|=(1<<M_PWMA_PIN);
 193               	.LM9:
 194 004e 2A9A      		sbi 37-0x20,2
 195               	.L8:
 196               	/* epilogue start */
 191:timers.c      **** 	//debugpf("\nCA:%c:%x",dirtoc(timer_2_dir),TCNT1);	
 192:timers.c      **** }
 198               	.LM10:
 199 0050 8F91      		pop r24
 200 0052 0F90      		pop r0
 201 0054 0FBE      		out __SREG__,r0
 202 0056 0F90      		pop r0
 203 0058 1F90      		pop __zero_reg__
 204 005a 1895      		reti
 206               	.Lscope3:
 208               		.stabd	78,0,0
 210               	.global	__vector_8
 212               	__vector_8:
 213               		.stabd	46,0,0
 193:timers.c      **** 
 194:timers.c      **** /* Timer/Counter Compare Match B */
 195:timers.c      **** ISR(TIMER1_COMPB_vect) {
 215               	.LM11:
 216               	.LFBB4:
 217 005c 1F92      		push __zero_reg__
 218 005e 0F92      		push r0
 219 0060 0FB6      		in r0,__SREG__
 220 0062 0F92      		push r0
 221 0064 1124      		clr __zero_reg__
 222 0066 8F93      		push r24
 223               	/* prologue: Signal */
 224               	/* frame size = 0 */
 196:timers.c      **** 	if (timer_2_dir==UP)	
 226               	.LM12:
 227 0068 8091 0000 		lds r24,timer_2_dir
 228 006c 8130      		cpi r24,lo8(1)
 229 006e 01F4      		brne .L10
 197:timers.c      **** 		MOTOR_PWM_PORT&=(uint8_t)~(1<<M_PWMB_PIN);
 231               	.LM13:
 232 0070 2B98      		cbi 37-0x20,3
 233 0072 00C0      		rjmp .L12
 234               	.L10:
 198:timers.c      **** 	else
 199:timers.c      **** 		MOTOR_PWM_PORT|=(1<<M_PWMB_PIN);
 236               	.LM14:
 237 0074 2B9A      		sbi 37-0x20,3
 238               	.L12:
 239               	/* epilogue start */
 200:timers.c      **** 	//debugpf("\nCB:%c:%x",dirtoc(timer_2_dir),TCNT1);
 201:timers.c      **** }
 241               	.LM15:
 242 0076 8F91      		pop r24
 243 0078 0F90      		pop r0
 244 007a 0FBE      		out __SREG__,r0
 245 007c 0F90      		pop r0
 246 007e 1F90      		pop __zero_reg__
 247 0080 1895      		reti
 249               	.Lscope4:
 251               		.stabd	78,0,0
 253               	.global	timer1_init
 255               	timer1_init:
 256               		.stabd	46,0,0
 258               	.LM16:
 259               	.LFBB5:
 260               	/* prologue: function */
 261               	/* frame size = 0 */
 263               	.LM17:
 264 0082 80E0      		ldi r24,lo8(__c.1578)
 265 0084 90E0      		ldi r25,hi8(__c.1578)
 266 0086 9F93      		push r25
 267 0088 8F93      		push r24
 268 008a 8091 0000 		lds r24,__iob+4
 269 008e 9091 0000 		lds r25,(__iob+4)+1
 270 0092 9F93      		push r25
 271 0094 8F93      		push r24
 272 0096 0E94 0000 		call fprintf_P
 274               	.LM18:
 275 009a E4E6      		ldi r30,lo8(100)
 276 009c F0E0      		ldi r31,hi8(100)
 277 009e 8081      		ld r24,Z
 278 00a0 877F      		andi r24,lo8(-9)
 279 00a2 8083      		st Z,r24
 281               	.LM19:
 282 00a4 E0E8      		ldi r30,lo8(128)
 283 00a6 F0E0      		ldi r31,hi8(128)
 284 00a8 8081      		ld r24,Z
 285 00aa 8F70      		andi r24,lo8(15)
 286 00ac 8083      		st Z,r24
 288               	.LM20:
 289 00ae 8081      		ld r24,Z
 290 00b0 8260      		ori r24,lo8(2)
 291 00b2 8083      		st Z,r24
 293               	.LM21:
 294 00b4 8081      		ld r24,Z
 295 00b6 8D7F      		andi r24,lo8(-3)
 296 00b8 8083      		st Z,r24
 298               	.LM22:
 299 00ba E1E8      		ldi r30,lo8(129)
 300 00bc F0E0      		ldi r31,hi8(129)
 301 00be 8081      		ld r24,Z
 302 00c0 8062      		ori r24,lo8(32)
 303 00c2 8083      		st Z,r24
 305               	.LM23:
 306 00c4 8081      		ld r24,Z
 307 00c6 8061      		ori r24,lo8(16)
 308 00c8 8083      		st Z,r24
 310               	.LM24:
 311 00ca 8081      		ld r24,Z
 312 00cc 877F      		andi r24,lo8(-9)
 313 00ce 8083      		st Z,r24
 315               	.LM25:
 316 00d0 8081      		ld r24,Z
 317 00d2 8F77      		andi r24,lo8(127)
 318 00d4 8083      		st Z,r24
 319               	.LBB9:
 321               	.LM26:
 322 00d6 2FB7      		in r18,__SREG__
 323               	.LBB10:
 324               	.LBB11:
 326               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
   4:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
   7:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  10:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  15:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  19:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** */
  31:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  32:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* $Id: atomic.h,v 1.3 2007/12/20 14:17:56 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  34:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  37:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  40:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  44:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     sei();
  45:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  47:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  48:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  50:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     cli();
 328               	.LM27:
 329               	/* #APP */
 330               	 ;  50 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h" 1
 331 00d8 F894      		cli
 332               	 ;  0 "" 2
 333               	/* #NOAPP */
 334               	.LBE11:
 335               	.LBE10:
 337               	.Ltext2:
 339               	.LM28:
 340 00da 8FEF      		ldi r24,lo8(-1)
 341 00dc 9FEF      		ldi r25,hi8(-1)
 342 00de 9093 8700 		sts (134)+1,r25
 343 00e2 8093 8600 		sts 134,r24
 344               	.LBB12:
 345               	.LBB13:
 347               	.Ltext3:
  51:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  53:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  54:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  56:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     sei();
  57:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     (void)__s;
  59:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  60:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  61:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  63:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     cli();
  64:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     (void)__s;
  66:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  67:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  68:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  70:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 349               	.LM29:
 350 00e6 2FBF      		out __SREG__,r18
  71:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 352               	.LM30:
 353               	.LBE13:
 354               	.LBE12:
 355               	.LBE9:
 357               	.Ltext4:
 359               	.LM31:
 360 00e8 E1E8      		ldi r30,lo8(129)
 361 00ea F0E0      		ldi r31,hi8(129)
 362 00ec 8081      		ld r24,Z
 363 00ee 897F      		andi r24,lo8(-7)
 364 00f0 8083      		st Z,r24
 366               	.LM32:
 367 00f2 8081      		ld r24,Z
 368 00f4 8160      		ori r24,lo8(1)
 369 00f6 8083      		st Z,r24
 371               	.LM33:
 372 00f8 EFE6      		ldi r30,lo8(111)
 373 00fa F0E0      		ldi r31,hi8(111)
 374 00fc 8081      		ld r24,Z
 375 00fe 8760      		ori r24,lo8(7)
 376 0100 8083      		st Z,r24
 378               	.LM34:
 379 0102 84B1      		in r24,36-0x20
 380 0104 8C60      		ori r24,lo8(12)
 381 0106 84B9      		out 36-0x20,r24
 383               	.LM35:
 384 0108 80E0      		ldi r24,lo8(__c.1585)
 385 010a 90E0      		ldi r25,hi8(__c.1585)
 386 010c 9F93      		push r25
 387 010e 8F93      		push r24
 388 0110 8091 0000 		lds r24,__iob+4
 389 0114 9091 0000 		lds r25,(__iob+4)+1
 390 0118 9F93      		push r25
 391 011a 8F93      		push r24
 392 011c 0E94 0000 		call fprintf_P
 393 0120 8DB7      		in r24,__SP_L__
 394 0122 9EB7      		in r25,__SP_H__
 395 0124 0896      		adiw r24,8
 396 0126 0FB6      		in __tmp_reg__,__SREG__
 397 0128 F894      		cli
 398 012a 9EBF      		out __SP_H__,r25
 399 012c 0FBE      		out __SREG__,__tmp_reg__
 400 012e 8DBF      		out __SP_L__,r24
 401               	/* epilogue start */
 403               	.LM36:
 404 0130 0895      		ret
 406               	.Lscope5:
 408               		.stabd	78,0,0
 410               	.global	__vector_5
 412               	__vector_5:
 413               		.stabd	46,0,0
 415               	.LM37:
 416               	.LFBB6:
 417 0132 1F92      		push __zero_reg__
 418 0134 0F92      		push r0
 419 0136 0FB6      		in r0,__SREG__
 420 0138 0F92      		push r0
 421 013a 1124      		clr __zero_reg__
 422 013c 8F93      		push r24
 423 013e 9F93      		push r25
 424               	/* prologue: Signal */
 425               	/* frame size = 0 */
 427               	.LM38:
 428 0140 8091 0000 		lds r24,sec.1567
 429 0144 9091 0000 		lds r25,(sec.1567)+1
 430 0148 0196      		adiw r24,1
 431 014a 9093 0000 		sts (sec.1567)+1,r25
 432 014e 8093 0000 		sts sec.1567,r24
 434               	.LM39:
 435 0152 8091 0000 		lds r24,c_mode
 436 0156 8823      		tst r24
 437 0158 01F4      		brne .L17
 439               	.LM40:
 440 015a 1F92      		push __zero_reg__
 441 015c 1F92      		push __zero_reg__
 442 015e 80E0      		ldi r24,lo8(__c.1568)
 443 0160 90E0      		ldi r25,hi8(__c.1568)
 444 0162 9F93      		push r25
 445 0164 8F93      		push r24
 446 0166 8091 0000 		lds r24,__iob+4
 447 016a 9091 0000 		lds r25,(__iob+4)+1
 448 016e 9F93      		push r25
 449 0170 8F93      		push r24
 450 0172 0E94 0000 		call fprintf_P
 451 0176 8DB7      		in r24,__SP_L__
 452 0178 9EB7      		in r25,__SP_H__
 453 017a 0696      		adiw r24,6
 454 017c 0FB6      		in __tmp_reg__,__SREG__
 455 017e F894      		cli
 456 0180 9EBF      		out __SP_H__,r25
 457 0182 0FBE      		out __SREG__,__tmp_reg__
 458 0184 8DBF      		out __SP_L__,r24
 459               	.L17:
 460               	/* epilogue start */
 462               	.LM41:
 463 0186 9F91      		pop r25
 464 0188 8F91      		pop r24
 465 018a 0F90      		pop r0
 466 018c 0FBE      		out __SREG__,r0
 467 018e 0F90      		pop r0
 468 0190 1F90      		pop __zero_reg__
 469 0192 1895      		reti
 474               	.Lscope6:
 476               		.stabd	78,0,0
 478               	.global	timer2_init
 480               	timer2_init:
 481               		.stabd	46,0,0
 483               	.LM42:
 484               	.LFBB7:
 485               	/* prologue: function */
 486               	/* frame size = 0 */
 488               	.LM43:
 489 0194 80E0      		ldi r24,lo8(__c.1521)
 490 0196 90E0      		ldi r25,hi8(__c.1521)
 491 0198 9F93      		push r25
 492 019a 8F93      		push r24
 493 019c 8091 0000 		lds r24,__iob+4
 494 01a0 9091 0000 		lds r25,(__iob+4)+1
 495 01a4 9F93      		push r25
 496 01a6 8F93      		push r24
 497 01a8 0E94 0000 		call fprintf_P
 499               	.LM44:
 500 01ac 8091 7000 		lds r24,112
 501 01b0 8C7F      		andi r24,lo8(-4)
 502 01b2 8093 7000 		sts 112,r24
 504               	.LM45:
 505 01b6 8091 B600 		lds r24,182
 506 01ba 8F7E      		andi r24,lo8(-17)
 507 01bc 8093 B600 		sts 182,r24
 509               	.LM46:
 510 01c0 8091 B600 		lds r24,182
 511 01c4 8860      		ori r24,lo8(8)
 512 01c6 8093 B600 		sts 182,r24
 514               	.LM47:
 515 01ca 1092 B200 		sts 178,__zero_reg__
 517               	.LM48:
 518 01ce 8091 B000 		lds r24,176
 519 01d2 8F77      		andi r24,lo8(127)
 520 01d4 8093 B000 		sts 176,r24
 522               	.LM49:
 523 01d8 8091 B000 		lds r24,176
 524 01dc 877B      		andi r24,lo8(-73)
 525 01de 8093 B000 		sts 176,r24
 527               	.LM50:
 528 01e2 8091 B000 		lds r24,176
 529 01e6 8F7C      		andi r24,lo8(-49)
 530 01e8 8093 B000 		sts 176,r24
 532               	.LM51:
 533 01ec 8091 B000 		lds r24,176
 534 01f0 8560      		ori r24,lo8(5)
 535 01f2 8093 B000 		sts 176,r24
 537               	.LM52:
 538 01f6 8091 B000 		lds r24,176
 539 01fa 8D7F      		andi r24,lo8(-3)
 540 01fc 8093 B000 		sts 176,r24
 541 0200 0F90      		pop __tmp_reg__
 542 0202 0F90      		pop __tmp_reg__
 543 0204 0F90      		pop __tmp_reg__
 544 0206 0F90      		pop __tmp_reg__
 545               	.L19:
 547               	.LM53:
 548 0208 8091 B600 		lds r24,182
 549 020c 82FD      		sbrc r24,2
 550 020e 00C0      		rjmp .L19
 551               	.L24:
 553               	.LM54:
 554 0210 8091 B600 		lds r24,182
 555 0214 81FD      		sbrc r24,1
 556 0216 00C0      		rjmp .L24
 557               	.L23:
 559               	.LM55:
 560 0218 8091 B600 		lds r24,182
 561 021c 80FD      		sbrc r24,0
 562 021e 00C0      		rjmp .L23
 564               	.LM56:
 565 0220 80E0      		ldi r24,lo8(__c.1529)
 566 0222 90E0      		ldi r25,hi8(__c.1529)
 567 0224 9F93      		push r25
 568 0226 8F93      		push r24
 569 0228 8091 0000 		lds r24,__iob+4
 570 022c 9091 0000 		lds r25,(__iob+4)+1
 571 0230 9F93      		push r25
 572 0232 8F93      		push r24
 573 0234 0E94 0000 		call fprintf_P
 574 0238 0F90      		pop __tmp_reg__
 575 023a 0F90      		pop __tmp_reg__
 576 023c 0F90      		pop __tmp_reg__
 577 023e 0F90      		pop __tmp_reg__
 578               	/* epilogue start */
 580               	.LM57:
 581 0240 0895      		ret
 583               	.Lscope7:
 585               		.stabd	78,0,0
 587               	.global	timers_init
 589               	timers_init:
 590               		.stabd	46,0,0
 202:timers.c      **** 
 203:timers.c      **** 
 204:timers.c      **** /*
 205:timers.c      **** void timer0_init(void) {}
 206:timers.c      **** */
 207:timers.c      **** 
 208:timers.c      **** void timers_init(void) {
 592               	.LM58:
 593               	.LFBB8:
 594               	/* prologue: function */
 595               	/* frame size = 0 */
 209:timers.c      **** 	fprintf_P(stderr,PSTR("\ntimers: init: start."));
 597               	.LM59:
 598 0242 80E0      		ldi r24,lo8(__c.1664)
 599 0244 90E0      		ldi r25,hi8(__c.1664)
 600 0246 9F93      		push r25
 601 0248 8F93      		push r24
 602 024a 8091 0000 		lds r24,__iob+4
 603 024e 9091 0000 		lds r25,(__iob+4)+1
 604 0252 9F93      		push r25
 605 0254 8F93      		push r24
 606 0256 0E94 0000 		call fprintf_P
 210:timers.c      **** //	timer0_init(); // Not implimented.
 211:timers.c      **** 	timer1_init(); //PWM
 608               	.LM60:
 609 025a 0E94 0000 		call timer1_init
 212:timers.c      **** 	timer2_init(); //RTC
 611               	.LM61:
 612 025e 0E94 0000 		call timer2_init
 213:timers.c      **** 	fprintf_P(stderr,PSTR("\ntimers: init:\t[done]"));
 614               	.LM62:
 615 0262 80E0      		ldi r24,lo8(__c.1666)
 616 0264 90E0      		ldi r25,hi8(__c.1666)
 617 0266 9F93      		push r25
 618 0268 8F93      		push r24
 619 026a 8091 0000 		lds r24,__iob+4
 620 026e 9091 0000 		lds r25,(__iob+4)+1
 621 0272 9F93      		push r25
 622 0274 8F93      		push r24
 623 0276 0E94 0000 		call fprintf_P
 624 027a 8DB7      		in r24,__SP_L__
 625 027c 9EB7      		in r25,__SP_H__
 626 027e 0896      		adiw r24,8
 627 0280 0FB6      		in __tmp_reg__,__SREG__
 628 0282 F894      		cli
 629 0284 9EBF      		out __SP_H__,r25
 630 0286 0FBE      		out __SREG__,__tmp_reg__
 631 0288 8DBF      		out __SP_L__,r24
 632               	/* epilogue start */
 214:timers.c      **** 	
 215:timers.c      **** }
 634               	.LM63:
 635 028a 0895      		ret
 637               	.Lscope8:
 639               		.stabd	78,0,0
 640               		.section	.progmem.data,"a",@progbits
 643               	__c.1666:
 644 0000 0A74 696D 		.string	"\ntimers: init:\t[done]"
 644      6572 733A 
 644      2069 6E69 
 644      743A 095B 
 644      646F 6E65 
 647               	__c.1664:
 648 0016 0A74 696D 		.string	"\ntimers: init: start."
 648      6572 733A 
 648      2069 6E69 
 648      743A 2073 
 648      7461 7274 
 651               	__c.1585:
 652 002c 095B 646F 		.string	"\t[done]"
 652      6E65 5D00 
 655               	__c.1578:
 656 0034 0A74 696D 		.string	"\ntimers: init: timer1"
 656      6572 733A 
 656      2069 6E69 
 656      743A 2074 
 656      696D 6572 
 659               	__c.1568:
 660 004a 0A4D 6F64 		.string	"\nMode: %d"
 660      653A 2025 
 660      6400 
 661               		.lcomm sec.1567,2
 664               	__c.1529:
 665 0054 095B 646F 		.string	"\t[done]"
 665      6E65 5D00 
 668               	__c.1521:
 669 005c 0A74 696D 		.string	"\ntimers: init: timer2"
 669      6572 733A 
 669      2069 6E69 
 669      743A 2074 
 669      696D 6572 
 670               		.lcomm timer_2_dir,1
 671               		.comm adc_val,8,1
 672               		.comm adc_offset,8,1
 673               		.comm adc_amt,8,1
 674               		.comm curr_ch,1,1
 675               		.comm c_mode,1,1
 676               		.comm initial,1,1
 692               		.text
 694               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timers.c
     /tmp/ccP7jG5b.s:2      *ABS*:0000003f __SREG__
     /tmp/ccP7jG5b.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccP7jG5b.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccP7jG5b.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccP7jG5b.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccP7jG5b.s:106    .text:00000000 __vector_9
     /tmp/ccP7jG5b.s:661    .bss:00000002 timer_2_dir
     /tmp/ccP7jG5b.s:139    .text:0000001e __vector_6
     /tmp/ccP7jG5b.s:169    .text:00000036 __vector_7
     /tmp/ccP7jG5b.s:212    .text:0000005c __vector_8
     /tmp/ccP7jG5b.s:255    .text:00000082 timer1_init
     /tmp/ccP7jG5b.s:655    .progmem.data:00000034 __c.1578
     /tmp/ccP7jG5b.s:651    .progmem.data:0000002c __c.1585
     /tmp/ccP7jG5b.s:412    .text:00000132 __vector_5
                             .bss:00000000 sec.1567
                            *COM*:00000001 c_mode
     /tmp/ccP7jG5b.s:659    .progmem.data:0000004a __c.1568
     /tmp/ccP7jG5b.s:480    .text:00000194 timer2_init
     /tmp/ccP7jG5b.s:668    .progmem.data:0000005c __c.1521
     /tmp/ccP7jG5b.s:664    .progmem.data:00000054 __c.1529
     /tmp/ccP7jG5b.s:589    .text:00000242 timers_init
     /tmp/ccP7jG5b.s:647    .progmem.data:00000016 __c.1664
     /tmp/ccP7jG5b.s:643    .progmem.data:00000000 __c.1666
                            *COM*:00000008 adc_val
                            *COM*:00000008 adc_offset
                            *COM*:00000008 adc_amt
                            *COM*:00000001 curr_ch
                            *COM*:00000001 initial

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__iob
fprintf_P
