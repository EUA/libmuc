   1               		.file	"timers.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 100               	.global	__vector_9
 102               	__vector_9:
 103               		.stabd	46,0,0
   1:timers.c      **** /* 
   2:timers.c      ****  * File: timers.c
   3:timers.c      ****  * Function: control of timers and pwm outputs
   4:timers.c      ****  */
   5:timers.c      **** 
   6:timers.c      **** #include "adc.h"
   7:timers.c      **** #include "defines.h"
   8:timers.c      **** #include <util/atomic.h>
   9:timers.c      **** #include <avr/io.h>
  10:timers.c      **** #include <avr/interrupt.h>
  11:timers.c      **** #include <stdio.h>
  12:timers.c      **** #include <avr/pgmspace.h>
  13:timers.c      **** 
  14:timers.c      **** 
  15:timers.c      **** void timer2_init(void) {
  16:timers.c      **** 	#ifdef debug
  17:timers.c      **** 	printf_P(PSTR("\ntimers: init: timer2"));
  18:timers.c      **** 	#endif
  19:timers.c      **** 	// External crystal : 32.768KHZ
  20:timers.c      **** 	/*
  21:timers.c      **** 	a. Disable the Timer/Counter2 interrupts by clearing OCIE2A and TOIE2.
  22:timers.c      **** 	b. Select clock source by setting AS2 as appropriate.
  23:timers.c      **** 	c. Write new values to TCNT2, OCR2A, and TCCR2A.
  24:timers.c      **** 	d. To switch to asynchronous operation: Wait for TCN2UB, OCR2UB, and TCR2UB.
  25:timers.c      **** 	e. Clear the Timer/Counter2 Interrupt Flags.
  26:timers.c      **** 	f. Enable interrupts, if needed.
  27:timers.c      **** 	*/
  28:timers.c      **** 	
  29:timers.c      **** 	// disable interupts (probably alread done)
  30:timers.c      **** 	TIMSK2&=(uint8_t)~((1<<OCIE2A)|(1<<TOIE2));
  31:timers.c      **** 	
  32:timers.c      **** 	// Enable asyncronous clocking.
  33:timers.c      **** 	ASSR&=(uint8_t)~(1<<EXCLK);
  34:timers.c      **** 	ASSR|=(uint8_t)(1<<AS2);
  35:timers.c      **** 	
  36:timers.c      **** 	// Reset acculumator
  37:timers.c      **** 	TCNT2 = 0;
  38:timers.c      **** 	
  39:timers.c      **** 	TCCR2A&=(uint8_t)~(1<<FOC2A);
  40:timers.c      **** 	
  41:timers.c      **** 	/* 	Mode	WGM21	WGM20	operation
  42:timers.c      **** 		0	0		0		Normal
  43:timers.c      **** 		1	0		1		PWM,Phase correct
  44:timers.c      **** 		2	1		0		CTC
  45:timers.c      **** 		3	1		1		Fast PWM
  46:timers.c      **** 	*/
  47:timers.c      **** 	// : CTC Mode.
  48:timers.c      **** 	//TCCR2A|=(1<<WGM20);
  49:timers.c      **** 	//TCCR2A&=~(1<<WGM21);
  50:timers.c      **** 	// : Normal Mode.
  51:timers.c      **** 	TCCR2A&=(uint8_t)~((1<<WGM20)|(1<<WGM21));
  52:timers.c      **** 	
  53:timers.c      **** 	/* Compare output mode (non-pwm) (OC2A)
  54:timers.c      **** 		COM2A1	COM2A0	Result
  55:timers.c      **** 		0		0		No output
  56:timers.c      **** 		0		1		Toggle on compare match
  57:timers.c      **** 		1		0		clear on compare match
  58:timers.c      **** 		1		1		set on 		"		"
  59:timers.c      **** 	*/
  60:timers.c      **** 	// : No output
  61:timers.c      **** 	TCCR2A&=(uint8_t)~((1<<COM2A1)|(1<<COM2A0));
  62:timers.c      **** 	
  63:timers.c      **** 	// Clock Select (Prescale) set
  64:timers.c      **** 
  65:timers.c      **** 	//32768/1/256 = 128Hz
  66:timers.c      **** 	//TCCR2A&=~((1<<CS22)|(1<<CS21));
  67:timers.c      **** 	//TCCR2A|= (1<<CS20);
  68:timers.c      **** 	
  69:timers.c      **** 	// 32768/8/256 = 16Hz
  70:timers.c      **** 	//TCCR2A|= (uint8_t)(1<<CS21);
  71:timers.c      **** 	//TCCR2A&=(uint8_t)~((uint8_t)((1<<CS20)|(1<<CS22)));
  72:timers.c      **** 
  73:timers.c      **** 	// 32768/128/256 = 1Hz
  74:timers.c      **** 	TCCR2A|= (1<<CS20)|(1<<CS22);
  75:timers.c      **** 	TCCR2A&=(uint8_t)~(1<<CS21);
  76:timers.c      **** 
  77:timers.c      **** 	// 32768/1024/256 = 1/8Hz
  78:timers.c      **** 	//TCCR2A|= (1<<CS21)|(1<<CS20)|(1<<CS22);
  79:timers.c      **** 
  80:timers.c      **** 	loop_until_bit_is_clear(ASSR,TCN2UB);
  81:timers.c      **** 	loop_until_bit_is_clear(ASSR,OCR2UB);
  82:timers.c      **** 	loop_until_bit_is_clear(ASSR,TCR2UB);
  83:timers.c      **** 	
  84:timers.c      **** 	// Enable overflow interrupt, disable match.
  85:timers.c      **** 	//TIMSK2|= (1<<TOIE2);
  86:timers.c      **** 	//TIMSK2&=~(1<<OCIE2A); // Disabled
  87:timers.c      **** 	#ifdef debug
  88:timers.c      **** 	printf_P(PSTR("\t[done]"));
  89:timers.c      **** 	#endif
  90:timers.c      **** }
  91:timers.c      **** 
  92:timers.c      **** 
  93:timers.c      **** // Timer2 Overflow
  94:timers.c      **** ISR(TIMER2_OVF_vect) {
  95:timers.c      **** 	static uint16_t sec;//=0
  96:timers.c      **** 	++sec;
  97:timers.c      **** 	if (c_mode==WAIT) {
  98:timers.c      **** 		//printf("\n\tT: %ds\n",sec);
  99:timers.c      **** 		#ifdef debug
 100:timers.c      **** 		printf_P(PSTR("\nMode: %d"),c_mode);
 101:timers.c      **** 		#endif
 102:timers.c      **** 	}
 103:timers.c      **** 
 104:timers.c      **** }
 105:timers.c      **** 
 106:timers.c      **** void timer1_init(void) { // Runs the PWMs
 107:timers.c      **** 	#ifdef debug
 108:timers.c      **** 	printf_P(PSTR("\ntimers: init: timer1"));
 109:timers.c      **** 	#endif
 110:timers.c      **** 	// Set OC1A/B on up, clear on down
 111:timers.c      **** //	TCCR1A|= (uint8_t) (1<<COM1A1)|(1<<COM1A0);
 112:timers.c      **** //	TCCR1A|= (uint8_t) (1<<COM1B1)|(1<<COM1B0);
 113:timers.c      **** 
 114:timers.c      **** 	// OC1A/B disconnected
 115:timers.c      **** 	TCCR1A&= (uint8_t) ~((1<<COM1A1)|(1<<COM1A0)|(1<<COM1B1)|(1<<COM1B0));
 116:timers.c      **** 	
 117:timers.c      **** 	// Waveform Generation Set to PWM (Phase and frequency correct, mode 8)
 118:timers.c      **** 	//TCCR1A&= (uint8_t) ~((1<<WGM11)|(1<<WGM10));
 119:timers.c      **** 	
 120:timers.c      **** 	// Phase correct only
 121:timers.c      **** 	TCCR1A|= (1<<WGM11);
 122:timers.c      **** 	TCCR1A&= (uint8_t) ~(1<<WGM11);
 123:timers.c      **** 	
 124:timers.c      **** 	TCCR1B|= (uint8_t) (1<<5); //Reserved bit
 125:timers.c      **** 	TCCR1B|= (uint8_t) (1<<WGM13);
 126:timers.c      **** 	TCCR1B&= (uint8_t)~(1<<WGM12);
 127:timers.c      **** 
 128:timers.c      **** 	// Disable Input noise canceler
 129:timers.c      **** 	TCCR1B|= (uint8_t)(1<<ICNC1);
 130:timers.c      **** 	
 131:timers.c      **** 	// Set TOP
 132:timers.c      **** 	ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 133:timers.c      **** 		ICR1=0xFFFF;
 134:timers.c      **** 	}
 135:timers.c      **** 	
 136:timers.c      **** 	// Note: f[OCnxPFCPWM]=f[pwm]=f[clk_io]/(2*Prescale*TOP);
 137:timers.c      **** 	//	Presacle = f[clk]/(2*f[pwm]*TOP)
 138:timers.c      **** 	//	Max f[pwm] for TB6612FNG is 100KHz (100000HZ)
 139:timers.c      **** 	//prescale = F_CPU/(2*100000*0xFFFF) = 
 140:timers.c      **** 	// At 8MHz the best we get is 60Hz (bad. very bad.)
 141:timers.c      **** 	
 142:timers.c      **** 	// Set prescale to 1
 143:timers.c      **** 	// TCCR1B = (TCCR1B & 0b11111000)|(log(prescale)/log(2));
 144:timers.c      **** 	TCCR1B&= (uint8_t)~((1<<CS12)|(1<<CS11));
 145:timers.c      **** 	TCCR1B|= (uint8_t) (1<<CS10);
 146:timers.c      **** 	
 147:timers.c      **** 	//OCR1A and OCR1B are the Compare / PWM registers
 148:timers.c      **** 	//OCR1A = OCR1B = 0xFFFF; // Max = 65535,0xFFFF
 149:timers.c      **** 	
 150:timers.c      **** 	// Enable the interupts, used to avoid the fucking speaker.
 151:timers.c      **** 	TIMSK1|=((1<<ICIE1)|(1<<OCIE1B)|(1<<OCIE1A)|(1<<TOIE1));
 152:timers.c      **** 	
 153:timers.c      **** 	MOTOR_PWM_DDR|= ((1<<M_PWMA_PIN)|(1<<M_PWMB_PIN));
 154:timers.c      **** 	#ifdef debug
 155:timers.c      **** 	printf_P(PSTR("\t[done]"));
 156:timers.c      **** 	#endif
 157:timers.c      **** }
 158:timers.c      **** 
 159:timers.c      **** enum {DOWN, UP};
 160:timers.c      **** static uint8_t timer_2_dir;
 161:timers.c      **** /* Timer/Counter1 Overflow ; BOTTOM */
 162:timers.c      **** ISR(TIMER1_OVF_vect) {
 105               	.LM0:
 106               	.LFBB1:
 107 0000 1F92      		push __zero_reg__
 108 0002 0F92      		push r0
 109 0004 0FB6      		in r0,__SREG__
 110 0006 0F92      		push r0
 111 0008 1124      		clr __zero_reg__
 112 000a 8F93      		push r24
 113               	/* prologue: Signal */
 114               	/* frame size = 0 */
 163:timers.c      **** 	timer_2_dir=UP;
 116               	.LM1:
 117 000c 81E0      		ldi r24,lo8(1)
 118 000e 8093 0000 		sts timer_2_dir,r24
 119               	/* epilogue start */
 164:timers.c      **** }
 121               	.LM2:
 122 0012 8F91      		pop r24
 123 0014 0F90      		pop r0
 124 0016 0FBE      		out __SREG__,r0
 125 0018 0F90      		pop r0
 126 001a 1F90      		pop __zero_reg__
 127 001c 1895      		reti
 129               	.Lscope1:
 131               		.stabd	78,0,0
 133               	.global	__vector_6
 135               	__vector_6:
 136               		.stabd	46,0,0
 165:timers.c      **** 
 166:timers.c      **** /* Timer/Counter1 ISR1 ; TOP */
 167:timers.c      **** ISR(SIG_INPUT_CAPTURE1) {
 138               	.LM3:
 139               	.LFBB2:
 140 001e 1F92      		push __zero_reg__
 141 0020 0F92      		push r0
 142 0022 0FB6      		in r0,__SREG__
 143 0024 0F92      		push r0
 144 0026 1124      		clr __zero_reg__
 145               	/* prologue: Signal */
 146               	/* frame size = 0 */
 168:timers.c      **** 	timer_2_dir=DOWN;
 148               	.LM4:
 149 0028 1092 0000 		sts timer_2_dir,__zero_reg__
 150               	/* epilogue start */
 169:timers.c      **** }
 152               	.LM5:
 153 002c 0F90      		pop r0
 154 002e 0FBE      		out __SREG__,r0
 155 0030 0F90      		pop r0
 156 0032 1F90      		pop __zero_reg__
 157 0034 1895      		reti
 159               	.Lscope2:
 161               		.stabd	78,0,0
 163               	.global	__vector_7
 165               	__vector_7:
 166               		.stabd	46,0,0
 170:timers.c      **** 
 171:timers.c      **** static char dirtoc(uint8_t dir){
 172:timers.c      **** 	if (dir==UP)
 173:timers.c      **** 		return 'U';
 174:timers.c      **** 	else if (dir==DOWN)
 175:timers.c      **** 		return 'D';
 176:timers.c      **** 	else
 177:timers.c      **** 		return '?';
 178:timers.c      **** }
 179:timers.c      **** 
 180:timers.c      **** 
 181:timers.c      **** /* Timer/Counter Compare Match A */
 182:timers.c      **** ISR(TIMER1_COMPA_vect) {
 168               	.LM6:
 169               	.LFBB3:
 170 0036 1F92      		push __zero_reg__
 171 0038 0F92      		push r0
 172 003a 0FB6      		in r0,__SREG__
 173 003c 0F92      		push r0
 174 003e 1124      		clr __zero_reg__
 175 0040 8F93      		push r24
 176               	/* prologue: Signal */
 177               	/* frame size = 0 */
 183:timers.c      **** 	if (timer_2_dir==UP)	
 179               	.LM7:
 180 0042 8091 0000 		lds r24,timer_2_dir
 181 0046 8130      		cpi r24,lo8(1)
 182 0048 01F4      		brne .L6
 184:timers.c      **** 		MOTOR_PWM_PORT&=(uint8_t)~(1<<M_PWMA_PIN);
 184               	.LM8:
 185 004a 2A98      		cbi 37-0x20,2
 186 004c 00C0      		rjmp .L8
 187               	.L6:
 185:timers.c      **** 	else
 186:timers.c      **** 		MOTOR_PWM_PORT|=(1<<M_PWMA_PIN);
 189               	.LM9:
 190 004e 2A9A      		sbi 37-0x20,2
 191               	.L8:
 192               	/* epilogue start */
 187:timers.c      **** 	//printf("\nCA:%c:%x",dirtoc(timer_2_dir),TCNT1);	
 188:timers.c      **** }
 194               	.LM10:
 195 0050 8F91      		pop r24
 196 0052 0F90      		pop r0
 197 0054 0FBE      		out __SREG__,r0
 198 0056 0F90      		pop r0
 199 0058 1F90      		pop __zero_reg__
 200 005a 1895      		reti
 202               	.Lscope3:
 204               		.stabd	78,0,0
 206               	.global	__vector_8
 208               	__vector_8:
 209               		.stabd	46,0,0
 189:timers.c      **** 
 190:timers.c      **** /* Timer/Counter Compare Match B */
 191:timers.c      **** ISR(TIMER1_COMPB_vect) {
 211               	.LM11:
 212               	.LFBB4:
 213 005c 1F92      		push __zero_reg__
 214 005e 0F92      		push r0
 215 0060 0FB6      		in r0,__SREG__
 216 0062 0F92      		push r0
 217 0064 1124      		clr __zero_reg__
 218 0066 8F93      		push r24
 219               	/* prologue: Signal */
 220               	/* frame size = 0 */
 192:timers.c      **** 	if (timer_2_dir==UP)	
 222               	.LM12:
 223 0068 8091 0000 		lds r24,timer_2_dir
 224 006c 8130      		cpi r24,lo8(1)
 225 006e 01F4      		brne .L10
 193:timers.c      **** 		MOTOR_PWM_PORT&=(uint8_t)~(1<<M_PWMB_PIN);
 227               	.LM13:
 228 0070 2B98      		cbi 37-0x20,3
 229 0072 00C0      		rjmp .L12
 230               	.L10:
 194:timers.c      **** 	else
 195:timers.c      **** 		MOTOR_PWM_PORT|=(1<<M_PWMB_PIN);
 232               	.LM14:
 233 0074 2B9A      		sbi 37-0x20,3
 234               	.L12:
 235               	/* epilogue start */
 196:timers.c      **** 	//printf("\nCB:%c:%x",dirtoc(timer_2_dir),TCNT1);
 197:timers.c      **** }
 237               	.LM15:
 238 0076 8F91      		pop r24
 239 0078 0F90      		pop r0
 240 007a 0FBE      		out __SREG__,r0
 241 007c 0F90      		pop r0
 242 007e 1F90      		pop __zero_reg__
 243 0080 1895      		reti
 245               	.Lscope4:
 247               		.stabd	78,0,0
 249               	.global	timer1_init
 251               	timer1_init:
 252               		.stabd	46,0,0
 254               	.LM16:
 255               	.LFBB5:
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 259               	.LM17:
 260 0082 80E0      		ldi r24,lo8(__c.1565)
 261 0084 90E0      		ldi r25,hi8(__c.1565)
 262 0086 9F93      		push r25
 263 0088 8F93      		push r24
 264 008a 0E94 0000 		call printf_P
 266               	.LM18:
 267 008e E0E8      		ldi r30,lo8(128)
 268 0090 F0E0      		ldi r31,hi8(128)
 269 0092 8081      		ld r24,Z
 270 0094 8F70      		andi r24,lo8(15)
 271 0096 8083      		st Z,r24
 273               	.LM19:
 274 0098 8081      		ld r24,Z
 275 009a 8260      		ori r24,lo8(2)
 276 009c 8083      		st Z,r24
 278               	.LM20:
 279 009e 8081      		ld r24,Z
 280 00a0 8D7F      		andi r24,lo8(-3)
 281 00a2 8083      		st Z,r24
 283               	.LM21:
 284 00a4 E1E8      		ldi r30,lo8(129)
 285 00a6 F0E0      		ldi r31,hi8(129)
 286 00a8 8081      		ld r24,Z
 287 00aa 8062      		ori r24,lo8(32)
 288 00ac 8083      		st Z,r24
 290               	.LM22:
 291 00ae 8081      		ld r24,Z
 292 00b0 8061      		ori r24,lo8(16)
 293 00b2 8083      		st Z,r24
 295               	.LM23:
 296 00b4 8081      		ld r24,Z
 297 00b6 877F      		andi r24,lo8(-9)
 298 00b8 8083      		st Z,r24
 300               	.LM24:
 301 00ba 8081      		ld r24,Z
 302 00bc 8068      		ori r24,lo8(-128)
 303 00be 8083      		st Z,r24
 304               	.LBB9:
 306               	.LM25:
 307 00c0 2FB7      		in r18,__SREG__
 308               	.LBB10:
 309               	.LBB11:
 311               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
   4:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
   7:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  10:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  15:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  19:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** */
  31:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  32:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* $Id: atomic.h,v 1.3 2007/12/20 14:17:56 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  34:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  37:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  40:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  44:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     sei();
  45:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  47:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  48:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  50:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     cli();
 313               	.LM26:
 314               	/* #APP */
 315               	 ;  50 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h" 1
 316 00c2 F894      		cli
 317               	 ;  0 "" 2
 318               	/* #NOAPP */
 319               	.LBE11:
 320               	.LBE10:
 322               	.Ltext2:
 324               	.LM27:
 325 00c4 8FEF      		ldi r24,lo8(-1)
 326 00c6 9FEF      		ldi r25,hi8(-1)
 327 00c8 9093 8700 		sts (134)+1,r25
 328 00cc 8093 8600 		sts 134,r24
 329               	.LBB12:
 330               	.LBB13:
 332               	.Ltext3:
  51:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  53:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  54:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  56:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     sei();
  57:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     (void)__s;
  59:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  60:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  61:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  63:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     cli();
  64:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     (void)__s;
  66:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  67:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  68:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  70:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 334               	.LM28:
 335 00d0 2FBF      		out __SREG__,r18
  71:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 337               	.LM29:
 338               	.LBE13:
 339               	.LBE12:
 340               	.LBE9:
 342               	.Ltext4:
 344               	.LM30:
 345 00d2 E1E8      		ldi r30,lo8(129)
 346 00d4 F0E0      		ldi r31,hi8(129)
 347 00d6 8081      		ld r24,Z
 348 00d8 897F      		andi r24,lo8(-7)
 349 00da 8083      		st Z,r24
 351               	.LM31:
 352 00dc 8081      		ld r24,Z
 353 00de 8160      		ori r24,lo8(1)
 354 00e0 8083      		st Z,r24
 356               	.LM32:
 357 00e2 EFE6      		ldi r30,lo8(111)
 358 00e4 F0E0      		ldi r31,hi8(111)
 359 00e6 8081      		ld r24,Z
 360 00e8 8762      		ori r24,lo8(39)
 361 00ea 8083      		st Z,r24
 363               	.LM33:
 364 00ec 84B1      		in r24,36-0x20
 365 00ee 8C60      		ori r24,lo8(12)
 366 00f0 84B9      		out 36-0x20,r24
 368               	.LM34:
 369 00f2 80E0      		ldi r24,lo8(__c.1572)
 370 00f4 90E0      		ldi r25,hi8(__c.1572)
 371 00f6 9F93      		push r25
 372 00f8 8F93      		push r24
 373 00fa 0E94 0000 		call printf_P
 374 00fe 0F90      		pop __tmp_reg__
 375 0100 0F90      		pop __tmp_reg__
 376 0102 0F90      		pop __tmp_reg__
 377 0104 0F90      		pop __tmp_reg__
 378               	/* epilogue start */
 380               	.LM35:
 381 0106 0895      		ret
 383               	.Lscope5:
 385               		.stabd	78,0,0
 387               	.global	__vector_5
 389               	__vector_5:
 390               		.stabd	46,0,0
 392               	.LM36:
 393               	.LFBB6:
 394 0108 1F92      		push __zero_reg__
 395 010a 0F92      		push r0
 396 010c 0FB6      		in r0,__SREG__
 397 010e 0F92      		push r0
 398 0110 1124      		clr __zero_reg__
 399 0112 8F93      		push r24
 400 0114 9F93      		push r25
 401               	/* prologue: Signal */
 402               	/* frame size = 0 */
 404               	.LM37:
 405 0116 8091 0000 		lds r24,sec.1555
 406 011a 9091 0000 		lds r25,(sec.1555)+1
 407 011e 0196      		adiw r24,1
 408 0120 9093 0000 		sts (sec.1555)+1,r25
 409 0124 8093 0000 		sts sec.1555,r24
 411               	.LM38:
 412 0128 8091 0000 		lds r24,c_mode
 413 012c 8823      		tst r24
 414 012e 01F4      		brne .L17
 416               	.LM39:
 417 0130 1F92      		push __zero_reg__
 418 0132 1F92      		push __zero_reg__
 419 0134 80E0      		ldi r24,lo8(__c.1556)
 420 0136 90E0      		ldi r25,hi8(__c.1556)
 421 0138 9F93      		push r25
 422 013a 8F93      		push r24
 423 013c 0E94 0000 		call printf_P
 424 0140 0F90      		pop __tmp_reg__
 425 0142 0F90      		pop __tmp_reg__
 426 0144 0F90      		pop __tmp_reg__
 427 0146 0F90      		pop __tmp_reg__
 428               	.L17:
 429               	/* epilogue start */
 431               	.LM40:
 432 0148 9F91      		pop r25
 433 014a 8F91      		pop r24
 434 014c 0F90      		pop r0
 435 014e 0FBE      		out __SREG__,r0
 436 0150 0F90      		pop r0
 437 0152 1F90      		pop __zero_reg__
 438 0154 1895      		reti
 443               	.Lscope6:
 445               		.stabd	78,0,0
 447               	.global	timer2_init
 449               	timer2_init:
 450               		.stabd	46,0,0
 452               	.LM41:
 453               	.LFBB7:
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 457               	.LM42:
 458 0156 80E0      		ldi r24,lo8(__c.1510)
 459 0158 90E0      		ldi r25,hi8(__c.1510)
 460 015a 9F93      		push r25
 461 015c 8F93      		push r24
 462 015e 0E94 0000 		call printf_P
 464               	.LM43:
 465 0162 8091 7000 		lds r24,112
 466 0166 8C7F      		andi r24,lo8(-4)
 467 0168 8093 7000 		sts 112,r24
 469               	.LM44:
 470 016c 8091 B600 		lds r24,182
 471 0170 8F7E      		andi r24,lo8(-17)
 472 0172 8093 B600 		sts 182,r24
 474               	.LM45:
 475 0176 8091 B600 		lds r24,182
 476 017a 8860      		ori r24,lo8(8)
 477 017c 8093 B600 		sts 182,r24
 479               	.LM46:
 480 0180 1092 B200 		sts 178,__zero_reg__
 482               	.LM47:
 483 0184 8091 B000 		lds r24,176
 484 0188 8F77      		andi r24,lo8(127)
 485 018a 8093 B000 		sts 176,r24
 487               	.LM48:
 488 018e 8091 B000 		lds r24,176
 489 0192 877B      		andi r24,lo8(-73)
 490 0194 8093 B000 		sts 176,r24
 492               	.LM49:
 493 0198 8091 B000 		lds r24,176
 494 019c 8F7C      		andi r24,lo8(-49)
 495 019e 8093 B000 		sts 176,r24
 497               	.LM50:
 498 01a2 8091 B000 		lds r24,176
 499 01a6 8560      		ori r24,lo8(5)
 500 01a8 8093 B000 		sts 176,r24
 502               	.LM51:
 503 01ac 8091 B000 		lds r24,176
 504 01b0 8D7F      		andi r24,lo8(-3)
 505 01b2 8093 B000 		sts 176,r24
 506 01b6 0F90      		pop __tmp_reg__
 507 01b8 0F90      		pop __tmp_reg__
 508               	.L19:
 510               	.LM52:
 511 01ba 8091 B600 		lds r24,182
 512 01be 82FD      		sbrc r24,2
 513 01c0 00C0      		rjmp .L19
 514               	.L24:
 516               	.LM53:
 517 01c2 8091 B600 		lds r24,182
 518 01c6 81FD      		sbrc r24,1
 519 01c8 00C0      		rjmp .L24
 520               	.L23:
 522               	.LM54:
 523 01ca 8091 B600 		lds r24,182
 524 01ce 80FD      		sbrc r24,0
 525 01d0 00C0      		rjmp .L23
 527               	.LM55:
 528 01d2 80E0      		ldi r24,lo8(__c.1518)
 529 01d4 90E0      		ldi r25,hi8(__c.1518)
 530 01d6 9F93      		push r25
 531 01d8 8F93      		push r24
 532 01da 0E94 0000 		call printf_P
 533 01de 0F90      		pop __tmp_reg__
 534 01e0 0F90      		pop __tmp_reg__
 535               	/* epilogue start */
 537               	.LM56:
 538 01e2 0895      		ret
 540               	.Lscope7:
 542               		.stabd	78,0,0
 544               	.global	timers_init
 546               	timers_init:
 547               		.stabd	46,0,0
 198:timers.c      **** 
 199:timers.c      **** 
 200:timers.c      **** /*
 201:timers.c      **** void timer0_init(void) {}
 202:timers.c      **** */
 203:timers.c      **** 
 204:timers.c      **** void timers_init(void) {
 549               	.LM57:
 550               	.LFBB8:
 551               	/* prologue: function */
 552               	/* frame size = 0 */
 205:timers.c      **** 	printf_P(PSTR("\ntimers: init: start."));
 554               	.LM58:
 555 01e4 80E0      		ldi r24,lo8(__c.1647)
 556 01e6 90E0      		ldi r25,hi8(__c.1647)
 557 01e8 9F93      		push r25
 558 01ea 8F93      		push r24
 559 01ec 0E94 0000 		call printf_P
 206:timers.c      **** //	timer0_init(); // Not implimented.
 207:timers.c      **** 	timer1_init(); //PWM
 561               	.LM59:
 562 01f0 0E94 0000 		call timer1_init
 208:timers.c      **** 	timer2_init(); //RTC
 564               	.LM60:
 565 01f4 0E94 0000 		call timer2_init
 209:timers.c      **** 	printf_P(PSTR("\ntimers: init:\t[done]"));
 567               	.LM61:
 568 01f8 80E0      		ldi r24,lo8(__c.1649)
 569 01fa 90E0      		ldi r25,hi8(__c.1649)
 570 01fc 9F93      		push r25
 571 01fe 8F93      		push r24
 572 0200 0E94 0000 		call printf_P
 573 0204 0F90      		pop __tmp_reg__
 574 0206 0F90      		pop __tmp_reg__
 575 0208 0F90      		pop __tmp_reg__
 576 020a 0F90      		pop __tmp_reg__
 577               	/* epilogue start */
 210:timers.c      **** 	
 211:timers.c      **** }
 579               	.LM62:
 580 020c 0895      		ret
 582               	.Lscope8:
 584               		.stabd	78,0,0
 585               		.section	.progmem.data,"a",@progbits
 588               	__c.1649:
 589 0000 0A74 696D 		.string	"\ntimers: init:\t[done]"
 589      6572 733A 
 589      2069 6E69 
 589      743A 095B 
 589      646F 6E65 
 592               	__c.1647:
 593 0016 0A74 696D 		.string	"\ntimers: init: start."
 593      6572 733A 
 593      2069 6E69 
 593      743A 2073 
 593      7461 7274 
 596               	__c.1572:
 597 002c 095B 646F 		.string	"\t[done]"
 597      6E65 5D00 
 600               	__c.1565:
 601 0034 0A74 696D 		.string	"\ntimers: init: timer1"
 601      6572 733A 
 601      2069 6E69 
 601      743A 2074 
 601      696D 6572 
 604               	__c.1556:
 605 004a 0A4D 6F64 		.string	"\nMode: %d"
 605      653A 2025 
 605      6400 
 606               		.lcomm sec.1555,2
 609               	__c.1518:
 610 0054 095B 646F 		.string	"\t[done]"
 610      6E65 5D00 
 613               	__c.1510:
 614 005c 0A74 696D 		.string	"\ntimers: init: timer2"
 614      6572 733A 
 614      2069 6E69 
 614      743A 2074 
 614      696D 6572 
 615               		.lcomm timer_2_dir,1
 616               		.comm adc_val,8,1
 617               		.comm adc_offset,8,1
 618               		.comm adc_amt,8,1
 619               		.comm curr_ch,1,1
 620               		.comm c_mode,1,1
 621               		.comm initial,1,1
 637               		.text
 639               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timers.c
     /tmp/ccqb03Wn.s:2      *ABS*:0000003f __SREG__
     /tmp/ccqb03Wn.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccqb03Wn.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccqb03Wn.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccqb03Wn.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccqb03Wn.s:102    .text:00000000 __vector_9
     /tmp/ccqb03Wn.s:606    .bss:00000002 timer_2_dir
     /tmp/ccqb03Wn.s:135    .text:0000001e __vector_6
     /tmp/ccqb03Wn.s:165    .text:00000036 __vector_7
     /tmp/ccqb03Wn.s:208    .text:0000005c __vector_8
     /tmp/ccqb03Wn.s:251    .text:00000082 timer1_init
     /tmp/ccqb03Wn.s:600    .progmem.data:00000034 __c.1565
     /tmp/ccqb03Wn.s:596    .progmem.data:0000002c __c.1572
     /tmp/ccqb03Wn.s:389    .text:00000108 __vector_5
                             .bss:00000000 sec.1555
                            *COM*:00000001 c_mode
     /tmp/ccqb03Wn.s:604    .progmem.data:0000004a __c.1556
     /tmp/ccqb03Wn.s:449    .text:00000156 timer2_init
     /tmp/ccqb03Wn.s:613    .progmem.data:0000005c __c.1510
     /tmp/ccqb03Wn.s:609    .progmem.data:00000054 __c.1518
     /tmp/ccqb03Wn.s:546    .text:000001e4 timers_init
     /tmp/ccqb03Wn.s:592    .progmem.data:00000016 __c.1647
     /tmp/ccqb03Wn.s:588    .progmem.data:00000000 __c.1649
                            *COM*:00000008 adc_val
                            *COM*:00000008 adc_offset
                            *COM*:00000008 adc_amt
                            *COM*:00000001 curr_ch
                            *COM*:00000001 initial

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
printf_P
