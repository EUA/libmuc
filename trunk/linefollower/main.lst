   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
 117               	.global	clock_init
 119               	clock_init:
   1:main.c        **** /*
   2:main.c        **** //Follow the damn line
   3:main.c        **** char Author [] ="Cody Schafer";
   4:main.c        **** */
   5:main.c        **** 
   6:main.c        **** #include <stdbool.h>
   7:main.c        **** #include "defines.h"
   8:main.c        **** #include "usart.h"
   9:main.c        **** #include "adc.h"
  10:main.c        **** #include "motor.h"
  11:main.c        **** #include "timers.h"
  12:main.c        **** #include "joystick.h"
  13:main.c        **** #include <avr/power.h>
  14:main.c        **** #include <stdio.h>
  15:main.c        **** #include <avr/io.h>
  16:main.c        **** #include <avr/interrupt.h>
  17:main.c        **** #include <util/delay.h>
  18:main.c        **** #include <avr/pgmspace.h>
  19:main.c        **** #include <stdlib.h>
  20:main.c        **** 
  21:main.c        **** 
  22:main.c        **** void clock_init(void) {
 121               	.LM0:
 122               	.LFBB1:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	.LBB30:
  23:main.c        **** 	
  24:main.c        **** 	#if   F_CPU == 1000000
  25:main.c        **** 		clock_prescale_set(clock_div_8);	
  26:main.c        **** 	#elif F_CPU == 2000000
  27:main.c        **** 		clock_prescale_set(clock_div_4);	
  28:main.c        **** 	#elif F_CPU == 4000000
  29:main.c        **** 		clock_prescale_set(clock_div_2);	
  30:main.c        **** 	#elif F_CPU == 8000000
  31:main.c        **** 		clock_prescale_set(clock_div_1);	
 127               	.LM1:
 128 0000 80E0      		ldi r24,lo8(0)
 129 0002 90E0      		ldi r25,hi8(0)
 130 0004 20E8      		ldi r18,lo8(-128)
 131               	/* #APP */
 132               	 ;  31 "main.c" 1
 133 0006 0FB6      		in __tmp_reg__,__SREG__
 134 0008 F894      		cli
 135 000a 2093 6100 		sts 97, r18
 136 000e 8093 6100 		sts 97, r24
 137 0012 0FBE      		out __SREG__, __tmp_reg__
 138               	 ;  0 "" 2
 139               	/* epilogue start */
 140               	/* #NOAPP */
 141               	.LBE30:
  32:main.c        **** 	#else
  33:main.c        **** 		#error "F_CPU Unrecognized"
  34:main.c        **** 	#endif
  35:main.c        **** 	
  36:main.c        **** 	//OSCAL set by the bootloader.
  37:main.c        **** }
 143               	.LM2:
 144 0014 0895      		ret
 146               	.Lscope1:
 148               	.global	__vector_default
 150               	__vector_default:
  38:main.c        **** 
  39:main.c        **** void  print_bin(uint8_t inp) {
  40:main.c        **** 	for(int8_t j=7; j>=0; --j) {
  41:main.c        **** 	   	fputc(((inp&(1<<j))>>j)+'0',stdout);
  42:main.c        **** 	}
  43:main.c        **** }
  44:main.c        **** 
  45:main.c        **** void init(void) {
  46:main.c        **** 	cli(); // Starts with interrupts disabled?
  47:main.c        **** 	power_all_enable();
  48:main.c        **** 	PCMSK1=PCMSK0=EIMSK=0; // Butterfly doesn't remove it's interupts, block them.
  49:main.c        **** 	clock_init();
  50:main.c        **** 	joy_init();
  51:main.c        **** 	usart_init();
  52:main.c        **** 	adc_init();
  53:main.c        **** 	timers_init();
  54:main.c        **** 	motors_init();
  55:main.c        **** 	sei();
  56:main.c        **** 	#if DEBUG_L(1)
  57:main.c        **** 	printf_P(PSTR("\nInit: Done\n\n"));
  58:main.c        **** 	#endif
  59:main.c        **** }
  60:main.c        **** 
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        **** int main(void) {
  64:main.c        **** 	init();
  65:main.c        **** 	c_mode=WAIT;
  66:main.c        **** 	initial=true;
  67:main.c        **** 		
  68:main.c        **** 	for(;;) {
  69:main.c        **** 		if	(c_mode==FOLLOW) {
  70:main.c        **** 			if (adc_data_new) {
  71:main.c        **** 				adc_data_new=false;
  72:main.c        **** 				if (initial) {
  73:main.c        **** 					initial=false;
  74:main.c        **** 					lf_speed_full();
  75:main.c        **** 				}
  76:main.c        **** 				
  77:main.c        **** 				// gen copy of fixed adc inputs.
  78:main.c        **** 				uint16_t adc_vc[channel_amt];
  79:main.c        **** 				for (uint8_t i=0;i<channel_amt;++i) {
  80:main.c        **** 					adc_vc[i]=adc_get_val(i);
  81:main.c        **** 				}
  82:main.c        **** 		
  83:main.c        **** 				uint8_t  max_i=channel_amt;
  84:main.c        **** 				uint16_t max_v=0;
  85:main.c        **** 				for (uint8_t i=0;i<channel_amt;++i) {
  86:main.c        **** 					if (adc_vc[i]>max_v) {
  87:main.c        **** 						max_i=i;
  88:main.c        **** 						max_v=adc_vc[i];
  89:main.c        **** 					}
  90:main.c        **** 				}
  91:main.c        **** 			
  92:main.c        **** 				#if DEBUG_L(1)
  93:main.c        **** 				print_adc_values();
  94:main.c        **** 				printf_P(PSTR("\nMax Chan [L 0 1 2 3 R]: %d;v=%d"),max_i,max_v);
  95:main.c        **** 				#endif
  96:main.c        **** 
  97:main.c        **** 				int8_t max_i_S;			
  98:main.c        **** 				max_i_S = max_i-channel_amt/2; 
  99:main.c        **** 				// Correction needed for even numbers of sensors.
 100:main.c        **** 				#if SENSOR_NUM_EVEN
 101:main.c        **** 				if (max_i_S>0)
 102:main.c        **** 					++max_i_S;	
 103:main.c        **** 				#endif
 104:main.c        **** 
 105:main.c        **** 				//Find Sensor "next to" max sensor.
 106:main.c        **** 				uint8_t next_i=0;
 107:main.c        **** 				uint16_t next_v;
 108:main.c        **** 				if (max_i_S>0)
 109:main.c        **** 					next_i=max_i-1;
 110:main.c        **** 				else if (max_i_S<0)
 111:main.c        **** 					next_i=max_i+1;
 112:main.c        **** 				#if SENSOR_NUM_ODD // Odd sensor nums only
 113:main.c        **** 				else
 114:main.c        **** 					next_i=0; // should be 1 or -1, which ever is larger.
 115:main.c        **** 				#endif
 116:main.c        **** 				
 117:main.c        **** 				//Hack for lack of zero sensor on even sensored bots.
 118:main.c        **** 				#if SENSOR_NUM_EVEN
 119:main.c        **** 				if (next_i==0) {
 120:main.c        **** 					if (max_i_S<0)
 121:main.c        **** 						++next_i;
 122:main.c        **** 					else // max_i_S>0
 123:main.c        **** 						--next_i;
 124:main.c        **** 				}
 125:main.c        **** 				#endif	
 126:main.c        **** 
 127:main.c        **** 				next_v=adc_vc[next_i];
 128:main.c        **** 				
 129:main.c        **** 				//TODO: Use next[vi], max[vi] to find a turn increment.
 130:main.c        **** 				lf_turn_inc(max_v-next_v,SIGN(max_i_S));				
 131:main.c        **** 	
 132:main.c        **** 				//lf_turn_inc(abs(LF_INC_SMALL*turn_i),turn_i>=0);
 133:main.c        **** 
 134:main.c        **** 
 135:main.c        **** 				printf_P(PSTR("\nTurn Increment: %d, dir:"),max_v-next_v,SIGN(max_i_S));
 136:main.c        **** 			
 137:main.c        **** 				uint16_t cspeed [2] = {	motor_get_speed(LEFT ),\
 138:main.c        **** 							motor_get_speed(RIGHT)};
 139:main.c        **** 				printf_P(PSTR("\nCurr Motors: L:%d %d:R"),cspeed[0],cspeed[1]);
 140:main.c        **** 				
 141:main.c        **** 			}
 142:main.c        **** 			
 143:main.c        **** 			else { // if !new_adc_data
 144:main.c        **** 				// Sleep? (need adc, timers, pwm outputs (IO clock), 
 145:main.c        **** 				printf_P(PSTR("\nWaiting for adc data?"));
 146:main.c        **** 				_delay_ms(300);
 147:main.c        **** 			}
 148:main.c        **** 			
 149:main.c        **** 		}
 150:main.c        **** 		else if	(c_mode==TEST) {
 151:main.c        **** 			if (initial) {
 152:main.c        **** 				initial=false;
 153:main.c        **** 				motor_mode(MOTOR_L_FWD,LEFT);
 154:main.c        **** 				motor_mode(MOTOR_R_FWD,RIGHT);
 155:main.c        **** 			}
 156:main.c        **** 			static uint16_t sp;
 157:main.c        **** 			
 158:main.c        **** 			motor_set_speed(sp,LEFT);
 159:main.c        **** 			motor_set_speed(sp,RIGHT);
 160:main.c        **** 			_delay_ms(2);
 161:main.c        **** 			//if (!(sp%0x100))
 162:main.c        **** 			//	printf("\nsp=%x",sp);
 163:main.c        **** 			++sp;
 164:main.c        **** 		}
 165:main.c        **** 	}	
 166:main.c        **** } 
 167:main.c        **** 		
 168:main.c        **** ISR(BADISR_vect) {
 152               	.LM3:
 153               	.LFBB2:
 154 0016 1F92      		push __zero_reg__
 155 0018 0F92      		push r0
 156 001a 0FB6      		in r0,__SREG__
 157 001c 0F92      		push r0
 158 001e 1124      		clr __zero_reg__
 159 0020 2F93      		push r18
 160 0022 3F93      		push r19
 161 0024 4F93      		push r20
 162 0026 5F93      		push r21
 163 0028 6F93      		push r22
 164 002a 7F93      		push r23
 165 002c 8F93      		push r24
 166 002e 9F93      		push r25
 167 0030 AF93      		push r26
 168 0032 BF93      		push r27
 169 0034 EF93      		push r30
 170 0036 FF93      		push r31
 171               	/* prologue: Signal */
 172               	/* frame size = 0 */
 169:main.c        **** 	fprintf_P(stderr,PSTR("\n\nInvalid Interupt Enabled\n"));
 174               	.LM4:
 175 0038 00D0      		rcall .
 176 003a 00D0      		rcall .
 177 003c 8091 0000 		lds r24,__iob+4
 178 0040 9091 0000 		lds r25,(__iob+4)+1
 179 0044 EDB7      		in r30,__SP_L__
 180 0046 FEB7      		in r31,__SP_H__
 181 0048 9283      		std Z+2,r25
 182 004a 8183      		std Z+1,r24
 183 004c 80E0      		ldi r24,lo8(__c.1787)
 184 004e 90E0      		ldi r25,hi8(__c.1787)
 185 0050 9483      		std Z+4,r25
 186 0052 8383      		std Z+3,r24
 187 0054 0E94 0000 		call fprintf_P
 188 0058 0F90      		pop __tmp_reg__
 189 005a 0F90      		pop __tmp_reg__
 190 005c 0F90      		pop __tmp_reg__
 191 005e 0F90      		pop __tmp_reg__
 192               	/* epilogue start */
 170:main.c        **** }
 194               	.LM5:
 195 0060 FF91      		pop r31
 196 0062 EF91      		pop r30
 197 0064 BF91      		pop r27
 198 0066 AF91      		pop r26
 199 0068 9F91      		pop r25
 200 006a 8F91      		pop r24
 201 006c 7F91      		pop r23
 202 006e 6F91      		pop r22
 203 0070 5F91      		pop r21
 204 0072 4F91      		pop r20
 205 0074 3F91      		pop r19
 206 0076 2F91      		pop r18
 207 0078 0F90      		pop r0
 208 007a 0FBE      		out __SREG__,r0
 209 007c 0F90      		pop r0
 210 007e 1F90      		pop __zero_reg__
 211 0080 1895      		reti
 213               	.Lscope2:
 215               	.global	init
 217               	init:
 219               	.LM6:
 220               	.LFBB3:
 221               	/* prologue: function */
 222               	/* frame size = 0 */
 224               	.LM7:
 225               	/* #APP */
 226               	 ;  46 "main.c" 1
 227 0082 F894      		cli
 228               	 ;  0 "" 2
 230               	.LM8:
 231               	/* #NOAPP */
 232 0084 E4E6      		ldi r30,lo8(100)
 233 0086 F0E0      		ldi r31,hi8(100)
 234 0088 8081      		ld r24,Z
 235 008a 807E      		andi r24,lo8(-32)
 236 008c 8083      		st Z,r24
 238               	.LM9:
 239 008e 1DBA      		out 61-0x20,__zero_reg__
 240 0090 8DB3      		in r24,61-0x20
 241 0092 EBE6      		ldi r30,lo8(107)
 242 0094 F0E0      		ldi r31,hi8(107)
 243 0096 8083      		st Z,r24
 244 0098 8081      		ld r24,Z
 245 009a 8093 6C00 		sts 108,r24
 246               	.LBB31:
 247               	.LBB32:
 248               	.LBB33:
 250               	.LM10:
 251 009e 80E0      		ldi r24,lo8(0)
 252 00a0 90E0      		ldi r25,hi8(0)
 253 00a2 20E8      		ldi r18,lo8(-128)
 254               	/* #APP */
 255               	 ;  31 "main.c" 1
 256 00a4 0FB6      		in __tmp_reg__,__SREG__
 257 00a6 F894      		cli
 258 00a8 2093 6100 		sts 97, r18
 259 00ac 8093 6100 		sts 97, r24
 260 00b0 0FBE      		out __SREG__, __tmp_reg__
 261               	 ;  0 "" 2
 262               	/* #NOAPP */
 263               	.LBE33:
 264               	.LBE32:
 265               	.LBE31:
 267               	.LM11:
 268 00b2 0E94 0000 		call joy_init
 270               	.LM12:
 271 00b6 0E94 0000 		call usart_init
 273               	.LM13:
 274 00ba 0E94 0000 		call adc_init
 276               	.LM14:
 277 00be 0E94 0000 		call timers_init
 279               	.LM15:
 280 00c2 0E94 0000 		call motors_init
 282               	.LM16:
 283               	/* #APP */
 284               	 ;  55 "main.c" 1
 285 00c6 7894      		sei
 286               	 ;  0 "" 2
 288               	.LM17:
 289               	/* #NOAPP */
 290 00c8 00D0      		rcall .
 291 00ca 80E0      		ldi r24,lo8(__c.1722)
 292 00cc 90E0      		ldi r25,hi8(__c.1722)
 293 00ce EDB7      		in r30,__SP_L__
 294 00d0 FEB7      		in r31,__SP_H__
 295 00d2 9283      		std Z+2,r25
 296 00d4 8183      		std Z+1,r24
 297 00d6 0E94 0000 		call printf_P
 298 00da 0F90      		pop __tmp_reg__
 299 00dc 0F90      		pop __tmp_reg__
 300               	/* epilogue start */
 302               	.LM18:
 303 00de 0895      		ret
 305               	.Lscope3:
 307               	.global	main
 309               	main:
 311               	.LM19:
 312               	.LFBB4:
 313 00e0 2F92      		push r2
 314 00e2 3F92      		push r3
 315 00e4 4F92      		push r4
 316 00e6 5F92      		push r5
 317 00e8 6F92      		push r6
 318 00ea 7F92      		push r7
 319 00ec 8F92      		push r8
 320 00ee 9F92      		push r9
 321 00f0 AF92      		push r10
 322 00f2 BF92      		push r11
 323 00f4 CF92      		push r12
 324 00f6 DF92      		push r13
 325 00f8 EF92      		push r14
 326 00fa FF92      		push r15
 327 00fc 0F93      		push r16
 328 00fe 1F93      		push r17
 329 0100 DF93      		push r29
 330 0102 CF93      		push r28
 331 0104 CDB7      		in r28,__SP_L__
 332 0106 DEB7      		in r29,__SP_H__
 333 0108 2897      		sbiw r28,8
 334 010a 0FB6      		in __tmp_reg__,__SREG__
 335 010c F894      		cli
 336 010e DEBF      		out __SP_H__,r29
 337 0110 0FBE      		out __SREG__,__tmp_reg__
 338 0112 CDBF      		out __SP_L__,r28
 339               	/* prologue: function */
 340               	/* frame size = 8 */
 342               	.LM20:
 343 0114 0E94 0000 		call init
 345               	.LM21:
 346 0118 1092 0000 		sts (c_mode)+1,__zero_reg__
 347 011c 1092 0000 		sts c_mode,__zero_reg__
 349               	.LM22:
 350 0120 81E0      		ldi r24,lo8(1)
 351 0122 8093 0000 		sts initial,r24
 352               	.LBB34:
 354               	.LM23:
 355 0126 5E01      		movw r10,r28
 356 0128 0894      		sec
 357 012a A11C      		adc r10,__zero_reg__
 358 012c B11C      		adc r11,__zero_reg__
 360               	.LM24:
 361 012e 70E0      		ldi r23,lo8(__c.1746)
 362 0130 272E      		mov r2,r23
 363 0132 70E0      		ldi r23,hi8(__c.1746)
 364 0134 372E      		mov r3,r23
 366               	.LM25:
 367 0136 60E0      		ldi r22,lo8(__c.1751)
 368 0138 462E      		mov r4,r22
 369 013a 60E0      		ldi r22,hi8(__c.1751)
 370 013c 562E      		mov r5,r22
 372               	.LM26:
 373 013e 50E0      		ldi r21,lo8(__c.1754)
 374 0140 652E      		mov r6,r21
 375 0142 50E0      		ldi r21,hi8(__c.1754)
 376 0144 752E      		mov r7,r21
 377               	.LBE34:
 378               	.LBB37:
 379               	.LBB38:
 380               	.LBB39:
 381               	.LBB40:
 382               	.LBB41:
 384               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** /** \file */
  40:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     \code
  42:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     \endcode
  44:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  45:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  53:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  60:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  62:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** */
  63:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  64:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** #endif
  68:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 386               	.LM27:
 387 0146 40EA      		ldi r20,lo8(4000)
 388 0148 842E      		mov r8,r20
 389 014a 4FE0      		ldi r20,hi8(4000)
 390 014c 942E      		mov r9,r20
 391               	.L30:
 392               	.LBE41:
 393               	.LBE40:
 394               	.LBE39:
 395               	.LBE38:
 396               	.LBE37:
 398               	.Ltext2:
 400               	.LM28:
 401 014e 8091 0000 		lds r24,c_mode
 402 0152 9091 0000 		lds r25,(c_mode)+1
 403 0156 0297      		sbiw r24,2
 404 0158 01F0      		breq .+2
 405 015a 00C0      		rjmp .L8
 407               	.LM29:
 408 015c 8091 0000 		lds r24,adc_data_new
 409 0160 8823      		tst r24
 410 0162 01F4      		brne .+2
 411 0164 00C0      		rjmp .L9
 412               	.LBB46:
 414               	.LM30:
 415 0166 1092 0000 		sts adc_data_new,__zero_reg__
 417               	.LM31:
 418 016a 8091 0000 		lds r24,initial
 419 016e 8823      		tst r24
 420 0170 01F0      		breq .L10
 422               	.LM32:
 423 0172 1092 0000 		sts initial,__zero_reg__
 425               	.LM33:
 426 0176 0E94 0000 		call lf_speed_full
 427               	.L10:
 428 017a 6501      		movw r12,r10
 429 017c 7501      		movw r14,r10
 430 017e 00E0      		ldi r16,lo8(0)
 431               	.L11:
 432               	.LBB35:
 434               	.LM34:
 435 0180 802F      		mov r24,r16
 436 0182 0E94 0000 		call adc_get_val
 437 0186 F701      		movw r30,r14
 438 0188 8193      		st Z+,r24
 439 018a 9193      		st Z+,r25
 440 018c 7F01      		movw r14,r30
 442               	.LM35:
 443 018e 0F5F      		subi r16,lo8(-(1))
 444 0190 0430      		cpi r16,lo8(4)
 445 0192 01F4      		brne .L11
 446 0194 80E0      		ldi r24,lo8(0)
 447 0196 90E0      		ldi r25,hi8(0)
 448 0198 20E0      		ldi r18,lo8(0)
 449               	.L15:
 450               	.LBE35:
 451               	.LBB36:
 453               	.LM36:
 454 019a F601      		movw r30,r12
 455 019c E080      		ld r14,Z
 456 019e F180      		ldd r15,Z+1
 457 01a0 8E15      		cp r24,r14
 458 01a2 9F05      		cpc r25,r15
 459 01a4 00F0      		brlo .L12
 460 01a6 7C01      		movw r14,r24
 461 01a8 00C0      		rjmp .L13
 462               	.L12:
 463 01aa 022F      		mov r16,r18
 464               	.L13:
 466               	.LM37:
 467 01ac 2F5F      		subi r18,lo8(-(1))
 468 01ae 82E0      		ldi r24,lo8(2)
 469 01b0 90E0      		ldi r25,hi8(2)
 470 01b2 C80E      		add r12,r24
 471 01b4 D91E      		adc r13,r25
 472 01b6 2430      		cpi r18,lo8(4)
 473 01b8 01F0      		breq .L14
 474 01ba C701      		movw r24,r14
 475 01bc 00C0      		rjmp .L15
 476               	.L14:
 477               	.LBE36:
 479               	.LM38:
 480 01be 0E94 0000 		call print_adc_values
 482               	.LM39:
 483 01c2 00D0      		rcall .
 484 01c4 00D0      		rcall .
 485 01c6 00D0      		rcall .
 486 01c8 ADB7      		in r26,__SP_L__
 487 01ca BEB7      		in r27,__SP_H__
 488 01cc 1196      		adiw r26,1
 489 01ce EDB7      		in r30,__SP_L__
 490 01d0 FEB7      		in r31,__SP_H__
 491 01d2 3282      		std Z+2,r3
 492 01d4 2182      		std Z+1,r2
 493 01d6 FD01      		movw r30,r26
 494 01d8 0283      		std Z+2,r16
 495 01da 1382      		std Z+3,__zero_reg__
 496 01dc F582      		std Z+5,r15
 497 01de E482      		std Z+4,r14
 498 01e0 0E94 0000 		call printf_P
 500               	.LM40:
 501 01e4 102F      		mov r17,r16
 502 01e6 1250      		subi r17,lo8(-(-2))
 504               	.LM41:
 505 01e8 8DB7      		in r24,__SP_L__
 506 01ea 9EB7      		in r25,__SP_H__
 507 01ec 0696      		adiw r24,6
 508 01ee 0FB6      		in __tmp_reg__,__SREG__
 509 01f0 F894      		cli
 510 01f2 9EBF      		out __SP_H__,r25
 511 01f4 0FBE      		out __SREG__,__tmp_reg__
 512 01f6 8DBF      		out __SP_L__,r24
 513 01f8 1116      		cp __zero_reg__,r17
 514 01fa 04F4      		brge .L16
 516               	.LM42:
 517 01fc 1F5F      		subi r17,lo8(-(1))
 519               	.LM43:
 520 01fe E12F      		mov r30,r17
 521 0200 00C0      		rjmp .L17
 522               	.L16:
 524               	.LM44:
 525 0202 1123      		tst r17
 526 0204 01F0      		breq .L18
 528               	.LM45:
 529 0206 E02F      		mov r30,r16
 530 0208 EF5F      		subi r30,lo8(-(1))
 531               	.L17:
 533               	.LM46:
 534 020a EE23      		tst r30
 535 020c 01F4      		brne .L19
 537               	.LM47:
 538 020e 17FF      		sbrs r17,7
 539 0210 00C0      		rjmp .L18
 540 0212 E1E0      		ldi r30,lo8(1)
 541 0214 00C0      		rjmp .L19
 542               	.L18:
 543 0216 EFEF      		ldi r30,lo8(-1)
 544               	.L19:
 546               	.LM48:
 547 0218 F0E0      		ldi r31,lo8(0)
 548 021a EE0F      		lsl r30
 549 021c FF1F      		rol r31
 550 021e EA0D      		add r30,r10
 551 0220 FB1D      		adc r31,r11
 552 0222 8081      		ld r24,Z
 553 0224 9181      		ldd r25,Z+1
 554 0226 E81A      		sub r14,r24
 555 0228 F90A      		sbc r15,r25
 556 022a 612F      		mov r22,r17
 557 022c 6095      		com r22
 558 022e 661F      		rol r22
 559 0230 6627      		clr r22
 560 0232 661F      		rol r22
 561 0234 C701      		movw r24,r14
 562 0236 0E94 0000 		call lf_turn_inc
 564               	.LM49:
 565 023a 00D0      		rcall .
 566 023c 00D0      		rcall .
 567 023e 00D0      		rcall .
 568 0240 ADB7      		in r26,__SP_L__
 569 0242 BEB7      		in r27,__SP_H__
 570 0244 1196      		adiw r26,1
 571 0246 EDB7      		in r30,__SP_L__
 572 0248 FEB7      		in r31,__SP_H__
 573 024a 5282      		std Z+2,r5
 574 024c 4182      		std Z+1,r4
 575 024e FD01      		movw r30,r26
 576 0250 F382      		std Z+3,r15
 577 0252 E282      		std Z+2,r14
 578 0254 812F      		mov r24,r17
 579 0256 9927      		clr r25
 580 0258 87FD      		sbrc r24,7
 581 025a 9095      		com r25
 582 025c 8095      		com r24
 583 025e 9095      		com r25
 584 0260 8827      		clr r24
 585 0262 990F      		lsl r25
 586 0264 881F      		rol r24
 587 0266 9927      		clr r25
 588 0268 9583      		std Z+5,r25
 589 026a 8483      		std Z+4,r24
 590 026c 0E94 0000 		call printf_P
 592               	.LM50:
 593 0270 8DB7      		in r24,__SP_L__
 594 0272 9EB7      		in r25,__SP_H__
 595 0274 0696      		adiw r24,6
 596 0276 0FB6      		in __tmp_reg__,__SREG__
 597 0278 F894      		cli
 598 027a 9EBF      		out __SP_H__,r25
 599 027c 0FBE      		out __SREG__,__tmp_reg__
 600 027e 8DBF      		out __SP_L__,r24
 601 0280 80E0      		ldi r24,lo8(0)
 602 0282 0E94 0000 		call motor_get_speed
 603 0286 7C01      		movw r14,r24
 604 0288 81E0      		ldi r24,lo8(1)
 605 028a 0E94 0000 		call motor_get_speed
 607               	.LM51:
 608 028e 00D0      		rcall .
 609 0290 00D0      		rcall .
 610 0292 00D0      		rcall .
 611 0294 ADB7      		in r26,__SP_L__
 612 0296 BEB7      		in r27,__SP_H__
 613 0298 1196      		adiw r26,1
 614 029a EDB7      		in r30,__SP_L__
 615 029c FEB7      		in r31,__SP_H__
 616 029e 7282      		std Z+2,r7
 617 02a0 6182      		std Z+1,r6
 618 02a2 FD01      		movw r30,r26
 619 02a4 F382      		std Z+3,r15
 620 02a6 E282      		std Z+2,r14
 621 02a8 9583      		std Z+5,r25
 622 02aa 8483      		std Z+4,r24
 623 02ac 0E94 0000 		call printf_P
 624 02b0 8DB7      		in r24,__SP_L__
 625 02b2 9EB7      		in r25,__SP_H__
 626 02b4 0696      		adiw r24,6
 627 02b6 0FB6      		in __tmp_reg__,__SREG__
 628 02b8 F894      		cli
 629 02ba 9EBF      		out __SP_H__,r25
 630 02bc 0FBE      		out __SREG__,__tmp_reg__
 631 02be 8DBF      		out __SP_L__,r24
 632 02c0 00C0      		rjmp .L30
 633               	.L9:
 634               	.LBE46:
 636               	.LM52:
 637 02c2 00D0      		rcall .
 638 02c4 80E0      		ldi r24,lo8(__c.1756)
 639 02c6 90E0      		ldi r25,hi8(__c.1756)
 640 02c8 EDB7      		in r30,__SP_L__
 641 02ca FEB7      		in r31,__SP_H__
 642 02cc 9283      		std Z+2,r25
 643 02ce 8183      		std Z+1,r24
 644 02d0 0E94 0000 		call printf_P
 645 02d4 88EB      		ldi r24,lo8(3000)
 646 02d6 9BE0      		ldi r25,hi8(3000)
 647 02d8 0F90      		pop __tmp_reg__
 648 02da 0F90      		pop __tmp_reg__
 649               	.L23:
 650               	.LBB47:
 651               	.LBB48:
 652               	.LBB49:
 653               	.LBB50:
 655               	.Ltext3:
 657               	.LM53:
 658 02dc E8EC      		ldi r30,lo8(200)
 659 02de F0E0      		ldi r31,hi8(200)
 660               	/* #APP */
 661               	 ;  105 "/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h" 1
 662 02e0 3197      		1: sbiw r30,1
 663 02e2 01F4      		brne 1b
 664               	 ;  0 "" 2
 665               	/* #NOAPP */
 666               	.LBE50:
 667               	.LBE49:
 669               	.Ltext4:
   1:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5 2007/10/28 23:25:56 joerg_wunsch Exp $ */
  34:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  39:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  40:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  41:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** /** \file */
  42:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  43:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     \code
  44:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  45:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  46:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  47:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     \endcode
  48:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  49:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  50:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  51:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  52:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     used.
  53:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  55:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  56:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  57:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  58:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  59:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  60:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  61:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  62:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  63:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  64:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  65:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  66:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  67:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  68:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  69:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  70:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  71:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  72:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  73:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  74:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  75:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  76:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** */
  77:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  78:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  79:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  80:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  81:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #endif
  82:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  84:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  85:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  86:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  87:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #endif
  88:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  89:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  90:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  91:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** #endif
  92:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  93:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** /**
  94:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
  95:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  96:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
  97:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  99:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 100:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
 101:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 102:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
 103:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 104:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 105:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 106:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****  */
 107:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** void
 108:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 109:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** {
 110:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 111:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 3e6) * __us;
 112:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 113:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 114:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 255)
 115:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	{
 116:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		_delay_ms(__us / 1000.0);
 117:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		return;
 118:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	}
 119:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	else
 120:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint8_t)__tmp;
 121:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	_delay_loop_1(__ticks);
 122:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** }
 123:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
 124:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
 125:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** /**
 126:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 127:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
 128:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 129:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
 130:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 131:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 132:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
 133:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 134:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 
 135:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 136:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 137:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 138:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 139:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 140:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** void
 142:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** {
 144:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 146:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 147:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 148:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 149:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 	{
 150:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 151:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 152:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 153:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 		{
 154:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 155:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 156:/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 671               	.LM54:
 672 02e4 0197      		sbiw r24,1
 674               	.LM55:
 675 02e6 01F4      		brne .L23
 676 02e8 00C0      		rjmp .L30
 677               	.L8:
 678               	.LBE48:
 679               	.LBE47:
 681               	.Ltext5:
 683               	.LM56:
 684 02ea 8091 0000 		lds r24,c_mode
 685 02ee 9091 0000 		lds r25,(c_mode)+1
 686 02f2 0197      		sbiw r24,1
 687 02f4 01F0      		breq .+2
 688 02f6 00C0      		rjmp .L30
 689               	.LBB51:
 691               	.LM57:
 692 02f8 8091 0000 		lds r24,initial
 693 02fc 8823      		tst r24
 694 02fe 01F0      		breq .L24
 696               	.LM58:
 697 0300 1092 0000 		sts initial,__zero_reg__
 699               	.LM59:
 700 0304 81E0      		ldi r24,lo8(1)
 701 0306 90E0      		ldi r25,hi8(1)
 702 0308 60E0      		ldi r22,lo8(0)
 703 030a 0E94 0000 		call motor_mode
 705               	.LM60:
 706 030e 81E0      		ldi r24,lo8(1)
 707 0310 90E0      		ldi r25,hi8(1)
 708 0312 61E0      		ldi r22,lo8(1)
 709 0314 0E94 0000 		call motor_mode
 710               	.L24:
 712               	.LM61:
 713 0318 8091 0000 		lds r24,sp.1758
 714 031c 9091 0000 		lds r25,(sp.1758)+1
 715 0320 60E0      		ldi r22,lo8(0)
 716 0322 0E94 0000 		call motor_set_speed
 718               	.LM62:
 719 0326 8091 0000 		lds r24,sp.1758
 720 032a 9091 0000 		lds r25,(sp.1758)+1
 721 032e 61E0      		ldi r22,lo8(1)
 722 0330 0E94 0000 		call motor_set_speed
 723               	.LBB45:
 724               	.LBB44:
 725               	.LBB43:
 726               	.LBB42:
 728               	.Ltext6:
 730               	.LM63:
 731 0334 C401      		movw r24,r8
 732               	/* #APP */
 733               	 ;  105 "/usr/lib/gcc/avr/4.3.2/../../../../avr/include/util/delay_basic.h" 1
 734 0336 0197      		1: sbiw r24,1
 735 0338 01F4      		brne 1b
 736               	 ;  0 "" 2
 737               	/* #NOAPP */
 738               	.LBE42:
 739               	.LBE43:
 740               	.LBE44:
 741               	.LBE45:
 743               	.Ltext7:
 745               	.LM64:
 746 033a 8091 0000 		lds r24,sp.1758
 747 033e 9091 0000 		lds r25,(sp.1758)+1
 748 0342 0196      		adiw r24,1
 749 0344 9093 0000 		sts (sp.1758)+1,r25
 750 0348 8093 0000 		sts sp.1758,r24
 751 034c 00C0      		rjmp .L30
 752               	.LBE51:
 786               	.Lscope4:
 789               	.global	print_bin
 791               	print_bin:
 793               	.LM65:
 794               	.LFBB5:
 795 034e EF92      		push r14
 796 0350 FF92      		push r15
 797 0352 0F93      		push r16
 798 0354 1F93      		push r17
 799 0356 CF93      		push r28
 800 0358 DF93      		push r29
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 804               	.LM66:
 805 035a C7E0      		ldi r28,lo8(7)
 806 035c D0E0      		ldi r29,hi8(7)
 807               	.LBB52:
 809               	.LM67:
 810 035e E1E0      		ldi r30,lo8(1)
 811 0360 EE2E      		mov r14,r30
 812 0362 F12C      		mov r15,__zero_reg__
 813 0364 082F      		mov r16,r24
 814 0366 10E0      		ldi r17,lo8(0)
 815               	.L32:
 816 0368 C701      		movw r24,r14
 817 036a 0C2E      		mov r0,r28
 818 036c 00C0      		rjmp 2f
 819 036e 880F      	1:	lsl r24
 820 0370 991F      		rol r25
 821 0372 0A94      	2:	dec r0
 822 0374 02F4      		brpl 1b
 823 0376 8023      		and r24,r16
 824 0378 9123      		and r25,r17
 825 037a 0C2E      		mov r0,r28
 826 037c 00C0      		rjmp 2f
 827 037e 9595      	1:	asr r25
 828 0380 8795      		ror r24
 829 0382 0A94      	2:	dec r0
 830 0384 02F4      		brpl 1b
 831 0386 6091 0000 		lds r22,__iob+2
 832 038a 7091 0000 		lds r23,(__iob+2)+1
 833 038e C096      		adiw r24,48
 834 0390 0E94 0000 		call fputc
 835 0394 2197      		sbiw r28,1
 837               	.LM68:
 838 0396 8FEF      		ldi r24,hi8(-1)
 839 0398 CF3F      		cpi r28,lo8(-1)
 840 039a D807      		cpc r29,r24
 841 039c 01F4      		brne .L32
 842               	/* epilogue start */
 843               	.LBE52:
 845               	.LM69:
 846 039e DF91      		pop r29
 847 03a0 CF91      		pop r28
 848 03a2 1F91      		pop r17
 849 03a4 0F91      		pop r16
 850 03a6 FF90      		pop r15
 851 03a8 EF90      		pop r14
 852 03aa 0895      		ret
 854               	.Lscope5:
 855               		.section	.progmem.data,"a",@progbits
 858               	__c.1787:
 859 0000 0A0A 496E 		.string	"\n\nInvalid Interupt Enabled\n"
 859      7661 6C69 
 859      6420 496E 
 859      7465 7275 
 859      7074 2045 
 860               		.lcomm sp.1758,2
 863               	__c.1756:
 864 001c 0A57 6169 		.string	"\nWaiting for adc data?"
 864      7469 6E67 
 864      2066 6F72 
 864      2061 6463 
 864      2064 6174 
 867               	__c.1754:
 868 0033 0A43 7572 		.string	"\nCurr Motors: L:%d %d:R"
 868      7220 4D6F 
 868      746F 7273 
 868      3A20 4C3A 
 868      2564 2025 
 871               	__c.1751:
 872 004b 0A54 7572 		.string	"\nTurn Increment: %d, dir:"
 872      6E20 496E 
 872      6372 656D 
 872      656E 743A 
 872      2025 642C 
 875               	__c.1746:
 876 0065 0A4D 6178 		.string	"\nMax Chan [L 0 1 2 3 R]: %d;v=%d"
 876      2043 6861 
 876      6E20 5B4C 
 876      2030 2031 
 876      2032 2033 
 879               	__c.1722:
 880 0086 0A49 6E69 		.string	"\nInit: Done\n\n"
 880      743A 2044 
 880      6F6E 650A 
 880      0A00 
 881               		.comm c_mode,2,1
 882               		.comm initial,1,1
 883               		.comm recieved,1,1
 884               		.comm adc_val,8,1
 885               		.comm adc_offset,8,1
 886               		.comm adc_amt,8,1
 887               		.comm curr_ch,1,1
 888               		.comm adc_data_new,1,1
 904               		.text
 906               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccE2Jb1W.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccE2Jb1W.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccE2Jb1W.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccE2Jb1W.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccE2Jb1W.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccE2Jb1W.s:119    .text:0000000000000000 clock_init
     /tmp/ccE2Jb1W.s:150    .text:0000000000000016 __vector_default
     /tmp/ccE2Jb1W.s:858    .progmem.data:0000000000000000 __c.1787
     /tmp/ccE2Jb1W.s:217    .text:0000000000000082 init
     /tmp/ccE2Jb1W.s:879    .progmem.data:0000000000000086 __c.1722
     /tmp/ccE2Jb1W.s:309    .text:00000000000000e0 main
                            *COM*:0000000000000002 c_mode
                            *COM*:0000000000000001 initial
     /tmp/ccE2Jb1W.s:875    .progmem.data:0000000000000065 __c.1746
     /tmp/ccE2Jb1W.s:871    .progmem.data:000000000000004b __c.1751
     /tmp/ccE2Jb1W.s:867    .progmem.data:0000000000000033 __c.1754
                            *COM*:0000000000000001 adc_data_new
     /tmp/ccE2Jb1W.s:863    .progmem.data:000000000000001c __c.1756
                             .bss:0000000000000000 sp.1758
     /tmp/ccE2Jb1W.s:791    .text:000000000000034e print_bin
                            *COM*:0000000000000001 recieved
                            *COM*:0000000000000008 adc_val
                            *COM*:0000000000000008 adc_offset
                            *COM*:0000000000000008 adc_amt
                            *COM*:0000000000000001 curr_ch

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__iob
fprintf_P
joy_init
usart_init
adc_init
timers_init
motors_init
printf_P
lf_speed_full
adc_get_val
print_adc_values
lf_turn_inc
motor_get_speed
motor_mode
motor_set_speed
fputc
