   1               		.file	"timers.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  85               	.global	timer2_init
  87               	timer2_init:
  88               		.stabd	46,0,0
   1:timers.c      **** /* 
   2:timers.c      ****  * File: timers.c
   3:timers.c      ****  * Function: control of timers and pwm outputs
   4:timers.c      ****  */
   5:timers.c      **** 
   6:timers.c      **** #include "adc.h"
   7:timers.c      **** #include "defines.h"
   8:timers.c      **** #include <util/atomic.h>
   9:timers.c      **** #include <avr/io.h>
  10:timers.c      **** #include <avr/interrupt.h>
  11:timers.c      **** #include <stdio.h>
  12:timers.c      **** 
  13:timers.c      **** 
  14:timers.c      **** 
  15:timers.c      **** void timer2_init(void) {
  90               	.LM0:
  91               	.LFBB1:
  92               	/* prologue: function */
  93               	/* frame size = 0 */
  16:timers.c      **** 	// External crystal : 32.768KHZ
  17:timers.c      **** 	/*
  18:timers.c      **** 	a. Disable the Timer/Counter2 interrupts by clearing OCIE2A and TOIE2.
  19:timers.c      **** 	b. Select clock source by setting AS2 as appropriate.
  20:timers.c      **** 	c. Write new values to TCNT2, OCR2A, and TCCR2A.
  21:timers.c      **** 	d. To switch to asynchronous operation: Wait for TCN2UB, OCR2UB, and TCR2UB.
  22:timers.c      **** 	e. Clear the Timer/Counter2 Interrupt Flags.
  23:timers.c      **** 	f. Enable interrupts, if needed.
  24:timers.c      **** 	*/
  25:timers.c      **** 	
  26:timers.c      **** 	// disable interupts (probably alread done)
  27:timers.c      **** 	TIMSK2&=(uint8_t)~((1<<OCIE2A)|(1<<TOIE2));
  95               	.LM1:
  96 0000 8091 7000 		lds r24,112
  97 0004 8C7F      		andi r24,lo8(-4)
  98 0006 8093 7000 		sts 112,r24
  28:timers.c      **** 	
  29:timers.c      **** 	// Enable asyncronous clocking.
  30:timers.c      **** 	ASSR&=~(uint8_t)(1<<EXCLK);
 100               	.LM2:
 101 000a 8091 B600 		lds r24,182
 102 000e 8F7E      		andi r24,lo8(-17)
 103 0010 8093 B600 		sts 182,r24
  31:timers.c      **** 	ASSR|=(uint8_t)(1<<AS2);
 105               	.LM3:
 106 0014 8091 B600 		lds r24,182
 107 0018 8860      		ori r24,lo8(8)
 108 001a 8093 B600 		sts 182,r24
  32:timers.c      **** 	
  33:timers.c      **** 	// Reset acculumator
  34:timers.c      **** 	TCNT2 = 0;
 110               	.LM4:
 111 001e 1092 B200 		sts 178,__zero_reg__
  35:timers.c      **** 	
  36:timers.c      **** 	TCCR2A&=(uint8_t)~(1<<FOC2A);
 113               	.LM5:
 114 0022 8091 B000 		lds r24,176
 115 0026 8F77      		andi r24,lo8(127)
 116 0028 8093 B000 		sts 176,r24
  37:timers.c      **** 	
  38:timers.c      **** 	/* 	Mode	WGM21	WGM20	operation
  39:timers.c      **** 		0	0		0		Normal
  40:timers.c      **** 		1	0		1		PWM,Phase correct
  41:timers.c      **** 		2	1		0		CTC
  42:timers.c      **** 		3	1		1		Fast PWM
  43:timers.c      **** 	*/
  44:timers.c      **** 	// : CTC Mode.
  45:timers.c      **** 	//TCCR2A|=(1<<WGM20);
  46:timers.c      **** 	//TCCR2A&=~(1<<WGM21);
  47:timers.c      **** 	// : Normal Mode.
  48:timers.c      **** 	TCCR2A&=(uint8_t)~((1<<WGM20)|(1<<WGM21));
 118               	.LM6:
 119 002c 8091 B000 		lds r24,176
 120 0030 877B      		andi r24,lo8(-73)
 121 0032 8093 B000 		sts 176,r24
  49:timers.c      **** 	
  50:timers.c      **** 	/* Compare output mode (non-pwm) (OC2A)
  51:timers.c      **** 		COM2A1	COM2A0	Result
  52:timers.c      **** 		0		0		No output
  53:timers.c      **** 		0		1		Toggle on compare match
  54:timers.c      **** 		1		0		clear on compare match
  55:timers.c      **** 		1		1		set on 		"		"
  56:timers.c      **** 	*/
  57:timers.c      **** 	// : No output
  58:timers.c      **** 	TCCR2A&=(uint8_t)~((1<<COM2A1)|(1<<COM2A0));
 123               	.LM7:
 124 0036 8091 B000 		lds r24,176
 125 003a 8F7C      		andi r24,lo8(-49)
 126 003c 8093 B000 		sts 176,r24
  59:timers.c      **** 	
  60:timers.c      **** 	// Clock Select (Prescale) set
  61:timers.c      **** 
  62:timers.c      **** 	//32768/1/256 = 128Hz
  63:timers.c      **** 	//TCCR2A&=~((1<<CS22)|(1<<CS21));
  64:timers.c      **** 	//TCCR2A|= (1<<CS20);
  65:timers.c      **** 	
  66:timers.c      **** 	// 32768/8/256 = 16Hz
  67:timers.c      **** 	//TCCR2A|= (uint8_t)(1<<CS21);
  68:timers.c      **** 	//TCCR2A&=(uint8_t)~((uint8_t)((1<<CS20)|(1<<CS22)));
  69:timers.c      **** 
  70:timers.c      **** 	// 32768/128/256 = 1Hz
  71:timers.c      **** 	TCCR2A|= (1<<CS20)|(1<<CS22);
 128               	.LM8:
 129 0040 8091 B000 		lds r24,176
 130 0044 8560      		ori r24,lo8(5)
 131 0046 8093 B000 		sts 176,r24
  72:timers.c      **** 	TCCR2A&=~(1<<CS21);
 133               	.LM9:
 134 004a 8091 B000 		lds r24,176
 135 004e 8D7F      		andi r24,lo8(-3)
 136 0050 8093 B000 		sts 176,r24
 137               	.L2:
  73:timers.c      **** 
  74:timers.c      **** 	// 32768/1024/256 = 1/8Hz
  75:timers.c      **** 	//TCCR2A|= (1<<CS21)|(1<<CS20)|(1<<CS22);
  76:timers.c      **** 
  77:timers.c      **** 	loop_until_bit_is_clear(ASSR,TCN2UB);
 139               	.LM10:
 140 0054 8091 B600 		lds r24,182
 141 0058 82FD      		sbrc r24,2
 142 005a 00C0      		rjmp .L2
 143               	.L7:
  78:timers.c      **** 	loop_until_bit_is_clear(ASSR,OCR2UB);
 145               	.LM11:
 146 005c 8091 B600 		lds r24,182
 147 0060 81FD      		sbrc r24,1
 148 0062 00C0      		rjmp .L7
 149               	.L6:
  79:timers.c      **** 	loop_until_bit_is_clear(ASSR,TCR2UB);
 151               	.LM12:
 152 0064 8091 B600 		lds r24,182
 153 0068 80FD      		sbrc r24,0
 154 006a 00C0      		rjmp .L6
  80:timers.c      **** 	
  81:timers.c      **** 	// Enable overflow interrupt, disable match.
  82:timers.c      **** 	TIMSK2|= (uint8_t)(1<<TOIE2);
 156               	.LM13:
 157 006c 8091 7000 		lds r24,112
 158 0070 8160      		ori r24,lo8(1)
 159 0072 8093 7000 		sts 112,r24
 160               	/* epilogue start */
  83:timers.c      **** 	//TIMSK2&=~(1<<OCIE2A); // Disabled
  84:timers.c      **** }
 162               	.LM14:
 163 0076 0895      		ret
 165               	.Lscope1:
 167               		.stabd	78,0,0
 169               	.global	timer1_init
 171               	timer1_init:
 172               		.stabd	46,0,0
  85:timers.c      **** 
  86:timers.c      **** 
  87:timers.c      **** // Timer2 Overflow
  88:timers.c      **** ISR(TIMER2_OVF_vect) {
  89:timers.c      **** 	static uint16_t sec;//=0
  90:timers.c      **** 	++sec;
  91:timers.c      **** 	//1 Hz (16/16)
  92:timers.c      **** 	printf("\tT: %ds\n",sec);
  93:timers.c      **** 	//print_adc_values();
  94:timers.c      **** 	//printf("Current Channel: %d\n", curr_ch);
  95:timers.c      **** }
  96:timers.c      **** 
  97:timers.c      **** void timer1_init(void) { // Runs the PWMs
 174               	.LM15:
 175               	.LFBB2:
 176               	/* prologue: function */
 177               	/* frame size = 0 */
  98:timers.c      **** 
  99:timers.c      **** 	// Set OC1A on up, clear on down
 100:timers.c      **** 	TCCR1A|= (uint8_t) (1<<COM1A1)|(1<<COM1A0);
 179               	.LM16:
 180 0078 E0E8      		ldi r30,lo8(128)
 181 007a F0E0      		ldi r31,hi8(128)
 182 007c 8081      		ld r24,Z
 183 007e 806C      		ori r24,lo8(-64)
 184 0080 8083      		st Z,r24
 101:timers.c      **** 	
 102:timers.c      **** 	// Set OC1B on up, clear on down
 103:timers.c      **** 	TCCR1A|= (uint8_t) (1<<COM1B1)|(1<<COM1B0);
 186               	.LM17:
 187 0082 8081      		ld r24,Z
 188 0084 8063      		ori r24,lo8(48)
 189 0086 8083      		st Z,r24
 104:timers.c      **** 	
 105:timers.c      **** 	// Waveform Generation Set to PWM (Phase and frequency correct, mode 8)
 106:timers.c      **** 	TCCR1A&= (uint8_t) ~((1<<WGM11)|(1<<WGM10));
 191               	.LM18:
 192 0088 8081      		ld r24,Z
 193 008a 8C7F      		andi r24,lo8(-4)
 194 008c 8083      		st Z,r24
 107:timers.c      **** 	TCCR1B|= (uint8_t) (1<<5); //Reserved bit
 196               	.LM19:
 197 008e E1E8      		ldi r30,lo8(129)
 198 0090 F0E0      		ldi r31,hi8(129)
 199 0092 8081      		ld r24,Z
 200 0094 8062      		ori r24,lo8(32)
 201 0096 8083      		st Z,r24
 108:timers.c      **** 	TCCR1B|= (uint8_t) (1<<WGM13);
 203               	.LM20:
 204 0098 8081      		ld r24,Z
 205 009a 8061      		ori r24,lo8(16)
 206 009c 8083      		st Z,r24
 109:timers.c      **** 	TCCR1B&= (uint8_t)~(1<<WGM12);
 208               	.LM21:
 209 009e 8081      		ld r24,Z
 210 00a0 877F      		andi r24,lo8(-9)
 211 00a2 8083      		st Z,r24
 110:timers.c      **** 	
 111:timers.c      **** 	// Disable Input noise canceler
 112:timers.c      **** 	TCCR1B|= (uint8_t)(1<<ICNC1);
 213               	.LM22:
 214 00a4 8081      		ld r24,Z
 215 00a6 8068      		ori r24,lo8(-128)
 216 00a8 8083      		st Z,r24
 217               	.LBB7:
 113:timers.c      **** 	
 114:timers.c      **** 	// Set TOP
 115:timers.c      **** 	ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
 219               	.LM23:
 220 00aa 2FB7      		in r18,__SREG__
 221               	.LBB8:
 222               	.LBB9:
 224               	.Ltext1:
   1:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
   4:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
   7:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  10:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  15:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  19:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** */
  31:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  32:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* $Id: atomic.h,v 1.3 2007/12/20 14:17:56 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  34:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  37:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  40:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  44:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     sei();
  45:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     return 1;
  46:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  47:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  48:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  50:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     cli();
 226               	.LM24:
 227               	/* #APP */
 228               	 ;  50 "/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h" 1
 229 00ac F894      		cli
 230               	 ;  0 "" 2
 231               	/* #NOAPP */
 232               	.LBE9:
 233               	.LBE8:
 235               	.Ltext2:
 116:timers.c      **** 		ICR1=0xFFFF;
 237               	.LM25:
 238 00ae 8FEF      		ldi r24,lo8(-1)
 239 00b0 9FEF      		ldi r25,hi8(-1)
 240 00b2 9093 8700 		sts (134)+1,r25
 241 00b6 8093 8600 		sts 134,r24
 242               	.LBB10:
 243               	.LBB11:
 245               	.Ltext3:
  51:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     return 1;
  52:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  53:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  54:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  56:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     sei();
  57:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     (void)__s;
  59:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  60:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  61:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  63:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     cli();
  64:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     (void)__s;
  66:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** }
  67:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** 
  68:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h **** {
  70:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     SREG = *__s;
 247               	.LM26:
 248 00ba 2FBF      		out __SREG__,r18
  71:/usr/lib/gcc/avr/4.3.0/../../../../avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 250               	.LM27:
 251               	.LBE11:
 252               	.LBE10:
 253               	.LBE7:
 255               	.Ltext4:
 117:timers.c      **** 	}
 118:timers.c      **** 	
 119:timers.c      **** 	// Note: f[OCnxPFCPWM]=f[pwm]=f[clk_io]/(2*Prescale*TOP);
 120:timers.c      **** 	//	Presacle = f[clk]/(2*f[pwm]*TOP)
 121:timers.c      **** 	//	Max f[pwm] for TB6612FNG is 100KHz (100000HZ)
 122:timers.c      **** 	//prescale = F_CPU/(2*100000*0xFFFF) = 
 123:timers.c      **** 	// At 8MHz the best we get is 60Hz (bad. very bad.)
 124:timers.c      **** 	
 125:timers.c      **** 	// Set prescale to 1
 126:timers.c      **** 	// TCCR1B = (TCCR1B & 0b11111000)|(log(prescale)/log(2));
 127:timers.c      **** 	TCCR1B&= (uint8_t)~((1<<CS12)|(1<<CS11));
 257               	.LM28:
 258 00bc E1E8      		ldi r30,lo8(129)
 259 00be F0E0      		ldi r31,hi8(129)
 260 00c0 8081      		ld r24,Z
 261 00c2 897F      		andi r24,lo8(-7)
 262 00c4 8083      		st Z,r24
 128:timers.c      **** 	TCCR1B|= (uint8_t) (1<<CS10);
 264               	.LM29:
 265 00c6 8081      		ld r24,Z
 266 00c8 8160      		ori r24,lo8(1)
 267 00ca 8083      		st Z,r24
 129:timers.c      **** 	
 130:timers.c      **** 	//OCR1A and OCR1B are the Compare / PWM registers
 131:timers.c      **** 	//OCR1A = OCR1B = 0xFFFF; // Max = 65535,0xFFFF
 132:timers.c      **** 	
 133:timers.c      **** 	// disable the interupts (probably done by default).
 134:timers.c      **** 	TIMSK1&= (uint8_t)~((1<<ICIE1)|(1<<OCIE1B)|(1<<OCIE1A)|(1<<TOIE1));
 269               	.LM30:
 270 00cc EFE6      		ldi r30,lo8(111)
 271 00ce F0E0      		ldi r31,hi8(111)
 272 00d0 8081      		ld r24,Z
 273 00d2 887D      		andi r24,lo8(-40)
 274 00d4 8083      		st Z,r24
 135:timers.c      **** 	
 136:timers.c      **** 	DDRB|= (uint8_t)(1<<PB5)|(1<<PB6);
 276               	.LM31:
 277 00d6 84B1      		in r24,36-0x20
 278 00d8 8066      		ori r24,lo8(96)
 279 00da 84B9      		out 36-0x20,r24
 280               	/* epilogue start */
 137:timers.c      **** }
 282               	.LM32:
 283 00dc 0895      		ret
 285               	.Lscope2:
 287               		.stabd	78,0,0
 289               	.global	timers_init
 291               	timers_init:
 292               		.stabd	46,0,0
 138:timers.c      **** /* Timer/Counter1 Overflow */
 139:timers.c      **** //ISR(TIMER1_OVF_vect) {}
 140:timers.c      **** 
 141:timers.c      **** /* Timer/Counter Compare Match A */
 142:timers.c      **** //ISR(TIMER1_COMPA_vect) {}
 143:timers.c      **** 
 144:timers.c      **** /* Timer/Counter Compare Match B */
 145:timers.c      **** ///ISR(TIMER1_COMPB_vect) {}
 146:timers.c      **** 
 147:timers.c      **** 
 148:timers.c      **** /*void timer0_init(void) {
 149:timers.c      **** }*/
 150:timers.c      **** 
 151:timers.c      **** void timers_init(void) {
 294               	.LM33:
 295               	.LFBB3:
 296               	/* prologue: function */
 297               	/* frame size = 0 */
 152:timers.c      **** //	timer0_init(); // Not implimented.
 153:timers.c      **** //	timer1_init(); //PWM
 154:timers.c      **** 	timer2_init(); //RTC
 299               	.LM34:
 300 00de 0E94 0000 		call timer2_init
 301               	/* epilogue start */
 155:timers.c      **** }
 303               	.LM35:
 304 00e2 0895      		ret
 306               	.Lscope3:
 308               		.stabd	78,0,0
 309               		.data
 310               	.LC0:
 311 0000 0954 3A20 		.string	"\tT: %ds\n"
 311      2564 730A 
 311      00
 312               		.text
 314               	.global	__vector_5
 316               	__vector_5:
 317               		.stabd	46,0,0
 319               	.LM36:
 320               	.LFBB4:
 321 00e4 1F92      		push __zero_reg__
 322 00e6 0F92      		push r0
 323 00e8 0FB6      		in r0,__SREG__
 324 00ea 0F92      		push r0
 325 00ec 1124      		clr __zero_reg__
 326 00ee 8F93      		push r24
 327 00f0 9F93      		push r25
 328               	/* prologue: Signal */
 329               	/* frame size = 0 */
 331               	.LM37:
 332 00f2 8091 0000 		lds r24,sec.1436
 333 00f6 9091 0000 		lds r25,(sec.1436)+1
 334 00fa 0196      		adiw r24,1
 335 00fc 9093 0000 		sts (sec.1436)+1,r25
 336 0100 8093 0000 		sts sec.1436,r24
 338               	.LM38:
 339 0104 9F93      		push r25
 340 0106 8F93      		push r24
 341 0108 80E0      		ldi r24,lo8(.LC0)
 342 010a 90E0      		ldi r25,hi8(.LC0)
 343 010c 9F93      		push r25
 344 010e 8F93      		push r24
 345 0110 0E94 0000 		call printf
 346 0114 0F90      		pop __tmp_reg__
 347 0116 0F90      		pop __tmp_reg__
 348 0118 0F90      		pop __tmp_reg__
 349 011a 0F90      		pop __tmp_reg__
 350               	/* epilogue start */
 352               	.LM39:
 353 011c 9F91      		pop r25
 354 011e 8F91      		pop r24
 355 0120 0F90      		pop r0
 356 0122 0FBE      		out __SREG__,r0
 357 0124 0F90      		pop r0
 358 0126 1F90      		pop __zero_reg__
 359 0128 1895      		reti
 364               	.Lscope4:
 366               		.stabd	78,0,0
 367               		.lcomm sec.1436,2
 368               		.comm adc_val,8,1
 369               		.comm adc_amt,8,1
 370               		.comm curr_ch,1,1
 376               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 timers.c
     /tmp/cctIz4Qk.s:2      *ABS*:0000003f __SREG__
     /tmp/cctIz4Qk.s:3      *ABS*:0000003e __SP_H__
     /tmp/cctIz4Qk.s:4      *ABS*:0000003d __SP_L__
     /tmp/cctIz4Qk.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/cctIz4Qk.s:6      *ABS*:00000001 __zero_reg__
     /tmp/cctIz4Qk.s:87     .text:00000000 timer2_init
     /tmp/cctIz4Qk.s:171    .text:00000078 timer1_init
     /tmp/cctIz4Qk.s:291    .text:000000de timers_init
     /tmp/cctIz4Qk.s:316    .text:000000e4 __vector_5
                             .bss:00000000 sec.1436
                            *COM*:00000008 adc_val
                            *COM*:00000008 adc_amt
                            *COM*:00000001 curr_ch

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
printf
